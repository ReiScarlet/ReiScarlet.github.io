{"meta":{"title":"Reimilia","subtitle":"","description":"","author":"Reimilia","url":"https://reiscarlet.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"05-14","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"12-12","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"04-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"05-14","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"05-17","excerpt":""}],"posts":[{"title":"Cache","text":"[toc] 1.Cache的基本结构Cache包括：SRAM，控制逻辑（主存地址寄存器、主存——Cache地址变换机构，替换控制器件和Cache地址寄存器） 2.Cache的读写操作2.1 读操作当CPU发出读请求时，如果Cache命中，就直接对Cache进行读操作； 如果Cache不命中，则访问主存，并把该信息从主存调入Cache内。 如果Cache满了，则根据替换算法替换Cache中原来的某个信息 2.2 写操作Cache保存的是主存的副本，当CPU发出写请求时 如果Cache命中，有可能会遇到Cache与主存内容不一致问题。 造成原因通常是： CPU写Cache后，没有立即写入主存； I/O写入主存后，没有立刻将信息从主存调入Cache更新。 处理的方法有： 写直达法：CPU把数据同时写入Cache和主存； 增加很多不必要的写主存操作，访问存储器速度会变慢 实现简单，随时保持存储数据的正确性 写回法：CPU把数据暂时只写入Cache，并用标志注明，等该块被替换时才写回主存。 减少很多不必要的写主存的操作，访问存储器的速度会提高 有可能出错，因为主存的字块有可能没有及时被修改 如果Cache不命中，直接把信息写入主存，并有两种处理方法 不按写分配法：只写入主存 按写分配法：写入主存，并将该块读入Cache 3. 地址映像把主存地址空间映像到Cache地址空间 全相联映像：主存的任一块可以被放置到Cache中的任意一个位置 空间利用率最高 块冲突率最低 实现复杂度最大 直接映像：主存中的每一块只能被放置到Cache的唯一一个位置（循环分配），也就是主存块的位置取模Cache块的个数 空间利用率最低 冲突概率最高 实现最简单 组相联映像：主存中的每一块可以被放置到Cache中的唯一的一个组中的任意一个位置 若主存的第i块映像到第k组，则k=i mod Cache的组数 例如：假设Cache有8个块，而主存有16个块，我们把Cache分为4各组（0，1，2，3），每个组有两个块，对应的主存也需要4个区，所以每个区有4个块。例如第9块位于区2（8(0)，9(1)，10(2)，11(3)）的第1个块，所以对应到Cache中的第1组的任意一个位置，也就是9mod4=1","path":"2021/12/03/计算机组成原理/第四章 存储系统/高速缓冲存储器/","date":"12-03","excerpt":"","tags":[]},{"title":"随机读写存储器","text":"[toc] 1. 静态RAM的基本单元电路SRAM的基本存储单元由6个MOS管组成，如下图 1.1 RAM组件 T1和T2管的状态决定了存储的信息 T1管导通，T2管截至，表示0状态 T1管截至，T2管导通，表示1状态 T3和T4管用作选通门，控制读写操作 T5和T6管是负载管 字线用来选择这个记忆单元 两条位线用来传送读写信号 1.2 运行过程选中记忆单元：当字线为低电平时，此时T3和T4管均为截止状态，触发器与位线隔开，原状态保持不变，当字线为高电平，T3和T4管导通，可以进行读写操作 读操作：两条位线均与A、B点相通，若此时记忆单元中T1管截止，T2管导通，B点电位为低，则读出“1”，反之读出“0” 写操作：令“位线I/O“为高电平，”位线I/O非“为低电平，使得B点电位为低，则使得T2管导通，T1管截止，也就是写入“1”，反之令“位线I/O”为低电平，“位线I/O非”为高电平，则为写“0”操作 2 动态RAM的刷新2.1 刷新间隔原因：为了维持DRAM记忆单元的存储信息，每隔一定时间必须刷新 在刷新与重写中： 重写是随机的，某个存储单元只有在破坏性读出之后才需要重写。 重写一般是按存储单元进行的 而刷新是定时的，即是许多记忆单元长期未被访问，若不及时补充电荷的话，信息是会丢失的 刷新通常是存储体矩阵中的一行为单位的 2.2 刷新方式2.2.1 集中刷新在允许的最大刷新间隔中，按照存储芯片容量的大小集中安排若干个刷新周期，刷新时停止读写操作 刷新时间 = 存储体行数 x 刷新周期，这里刷新周期是指刷新一行所需要的时间，所以刷新周期就是存取周期 例如：对于有1024个记忆单元（32*32的存储矩阵，因为方阵是最利于集中的）的存储芯片刷新，需要32个刷新周期，如果存取周期为0.5μs，则在2ms的刷新间隔中，前1984μs是读写周期，而后16μs为刷新周期，也是死区 优缺点： 读写操作不受刷新工作影响，存取速度快 集中刷新期间必须停止读写，称为死区，且存储容量越大，死区越长 2.2.2 分散刷新把刷新操作分散到每个存取周期，这种刷新方式增加了系统的存取周期 如果芯片的存取周期为0.5μs，我们仍以32*32的矩阵为例，每次存取在刷新需要1μs，刷新32次后整个刷新间隔则为32μs 优缺点： 没有死区 加长了系统的存取周期，降低了整机的速度 刷新过于频繁（例如32μs），没有充分利用最大刷新间隔（例如2ms） 2.2.3 异步刷新充分利用最大刷新间隔时间，把刷新操作平均分配到最大刷新间隔时间内 相邻两行的刷新间隔=最大刷新间隔时间/行数 例如：对于32*32矩阵，2ms内要刷新32次，则每次要刷新2ms/32次=62.5μs，则每个刷新周期（62.5μs）中，前62μs为读写操作，后0.5μs为刷新操作 优缺点： 有死区，但死区比起集中刷新要小，为0.5μs 减少了刷新次数 2.3 刷新控制为了控制刷新，需要控制刷新电路。控制刷新电路的主要任务是解决刷新和CPU访问存储器之间的矛盾，当刷新和访问请求同时发生，优先刷新操作 2.4 DRAM刷新的注意事项 刷新对CPU是透明的 每一行中各记忆单元同时被刷新，故刷新操作仅需要行地址 刷新操作类似读出操作，但不需要信息输出 刷新时不需要片选信号，因为存储器中所有芯片同时刷新 由于芯片同时被刷新，所以刷新问题应当从单个芯片的存储容量着手，而不是整个存储器的容量 3 RAM的读写时序读周期：表示对芯片心距两次连续读操作的最小间隔时间，在这个过程中地址输入信息不允许改变，片选信号在地址有效后生效，使芯片被选中，最后在数据线上得到读出的信号 写周期：写周期和读周期相似，除了地址和片选信号外，还要加一个低电平有效的写入脉冲，并提供写入数据 4 RAM芯片分析RAM芯片通过地址线、数据线和控制线与外部连接 地址线是单向输入，其数目与芯片容量有关，如容量为1024x4时，地址线有10根，因为$2^{10}=1024$，容量为64K1时，地址线为16根，因为$2^6 2^{10}(1K) = 2^{16}$。 数据线是双向的，其数目与数据位线有关，如1024x4的芯片，数据线有4根，64Kx1的芯片，数据线有1根 控制线：有读写控制线$\\overline{WE}$和片选线$\\overline{CS}$两种，片选线决定该芯片是否被选中，读写控制线用来控制芯片进行读操作还是写操作 为了减少芯片的引脚数量，DRAM芯片把地址线分为相等的两部分，分两次从相同的引脚送入，两次输入的地址分别是行地址和列地址，行地址由行地址选通信号送入存储芯片，列地址有列地址选通信号送入存储芯片 由于采用了地址复用技术，所以DRAM每增加一条地址线，实际上增加两位地址，也就是4倍的容量","path":"2021/12/03/计算机组成原理/第四章 存储系统/随机读写存储器/","date":"12-03","excerpt":"","tags":[]},{"title":"存储器的组成","text":"[toc] 存储器的分类按存储介质分类： 半导体存储器 优点：体积小、功耗低、存取时间短 缺点：当电源停止供电，所存信息立即丢失，是一种易失性存储器 磁表面存储器 优点：是一种非易失性存储器 磁芯存储器 优点：不易失的永久记忆存储器 缺点：体积过大、工艺复杂、功耗太大 光盘存储器 优点：记录密度高、耐用性好、可靠性高和可互换性强，非易失性 按存取方式分类： 随机存取存储器RAM：存取时间与存储单元的物理位置无关，分为SRAM（触发器原理），DRAM（电容充放电原理） 只读存储器ROM： 有掩膜型只读存储器（Masked ROM, MROM）：生产时由制造产用掩膜奇数将一定的程序写入其中，写入后的程序用户不能更改，只能读出 可编程只读存储器（Programmable ROM, PROM）：程序由用户自行写入，一经写入，就无法更改 可擦除可编程只读存储器（Erasable Programmable ROM, EPROM）：可由用户自行写入程序，写入后的内容可用紫外线灯照射来擦除，然后重新写入新的程序，且可多次擦除，多次改写 用电可擦除可编程的只读存储器（Electrically Erasable Programmable ROM, EEPROM）：用可用电信号进行清除和重写的存储器 快擦型存储器Flash Memory：即可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写，具备EPROM和RAM的优点 串行访问存储器：按物理位置的现后顺序寻找地址 直接存取存储器 存储器的分级结构目的：为了解决单个存储器容量和速度的矛盾，应用了访问局部性原理，即把存储体系设计成层次化的结构以满足使用要求 存储器的层次结构主要体现在Cache——主存储器（Cache存储系统）和主存储器——辅助存储器（虚拟存储器） Cache存储系统是为了解决主存储器速度的不足而提出来的。在Cache和主存储器之间，增加了辅助硬件，让它们构成一个整体 虚拟存储器是为了解决主存储器容量不足而提出来的。在主存储器和辅助存储器之间增加辅助的软硬件，让它们构成一个整体。例如我们cpu无法直接访问硬盘，必须先用操作系统将硬盘的数据读到主存，硬件就是硬盘，所以是借助软硬件","path":"2021/12/03/计算机组成原理/第四章 存储系统/存储器的组成/","date":"12-03","excerpt":"","tags":[]},{"title":"主存储器的连接与控制","text":"[toc] 一、主存容量的拓展步骤： 计算所需芯片数目 确定拓展方式 确定片选逻辑并连线实现 分析存储地址空间映像 1.计算所需芯片数目公式： \\begin{aligned} 芯片数 &= \\frac{要求实现的存储器容量}{已知的单个存储芯片容量}\\\\ &=\\frac{要求实现存储器存储单元个数*位数/单元}{已知单个存储芯片存储单元的个数*位数/单元}\\\\ &=M*N \\end{aligned}2.确定拓展方式如果$M\\neq1$则需要字拓展，如果$N\\neq1$则需要位拓展 3.确定片选逻辑并连线实现片选是指集成电路芯片能否工作的一个控制信号 该信号的产生逻辑即片选逻辑。一般由CPU的地址信号和一些控制信号通过组合逻辑电路产生，同时考虑时序关系 连线主要是指CPU的三总线与存储器芯片的信号引脚的连接 三总线是指：数据总线，地址总线，控制总线； 存储芯片的信号：片选信号与读写控制信号 CS：片选线 WE：读写控制线 3.1 位拓展的连接如果用64K*1的SRAM芯片组成64K*8的的存储器，所需的芯片数为1*8=8个。因为$N\\neq1$所以需要位拓展 组成的存储器具有$64K=2^{16}$个存储单元，每个存储单元具有8个位数 CPU将提供16根地址线，8根数据线与存储器相连；一个存储芯片则具有16根地址线，1根数据线。 具体的连接方法是：每个芯片的地址线$A_{15}\\sim A_0$都是分别连在一起（例如所有芯片的$A_0$地址线连在一个，这样每次都能选到所有芯片的同一位），每个芯片的片选信号$\\overline{CS}$以及读写控制信号$\\overline{WE}$也都分别连在一起，只有数据线$D_7\\sim D_0$独立，每片芯片提供一位 具体细节：当CPU访问存储器时，发出的地址信号传到8个芯片，选中8个芯片的同一单元，8个单元各提供一位数据，被读到数据总线，或将数据总线的内容写入 注意：所有的片选信号和读写控制信号都是连在一起的 ![image-20210616151112148](../img/image-20210616151112148.png) ### 3.2 字拓展的连接 如用16K\\*8的SRAM组成64K\\*8的存储器，则需要4\\*1=4个芯片，由于$M\\neq1$需要字拓展 同样的，CPU将提供16根地址线，8根数据线，而每个芯片提供14根地址线，8根数据线 具体的连接方法是：4个芯片的地址线$A_{13}\\sim A_0$，数据线$D_7\\sim D_0$和读写控制信号都是独立的（4个芯片都并联连着$A_{13}\\sim A_0,D_7\\sim D_0$），而CPU比芯片多出来的$A_{15},A_{14}$两个地址线经过2-4译码产生4个片选信号，选中一个芯片（由于芯片提供8位，而组成的存储器也只提供8位，所以一个芯片就能够提供8位数据，只需要选中一个芯片即可） 注意：片选信号都是分开的 ![image-20210616152700819](../img/image-20210616152700819.png) ## 4.地址存储映像分析 - 存储器连线完毕后，每个芯片中的每个存储单元在整个CPU地址空间中的位置也就确定下来，把每个芯片所对应的地址范围描述出来就是地址的存储映像分析 - 基本方法是：将所有地址信号排列出来，将所有可能的变化分析写出，再总结每个芯片对应的范围 ### 4.1 字拓展的地址映像 续字拓展连接的例子：同一时间4个芯片中只有1个芯片能被选中，CPU提供的$A_{15}\\sim A_{0}$的16位地址线中，$A_{15}、A_{14}$用作片选，$A_{13}\\sim A_{0}$用来选中芯片的某个地址，固称片内地址 例如第一片的地址映像为： 第一片 最低地址：$00|00\\ 0000\\ 0000\\ 0000B$ 最高地址：$00|11\\ 1111\\ 1111\\ 1111B$ 二、存储芯片的地址分配和片选字选：从选中的芯片中按照地址码选择出相应的存储单元，以进行数据的存取 片选：选择存储芯片 存储芯片的片选信号大都通过高位地址译码产生 片选信号的译码方法分为： 线选法 全译码法 部分译码法 1. 线选法除了片内寻址外的高位地址线直接分别接到各个存储芯片的片选段 每次寻址时只能有一位有效，以保证每次只选中一个芯片（或组） 优点：(1)不需要地址译码器；(2)线路简单 缺点：(1)仅适用连接存储芯片较少的场合；(2)给编程带来了一定的困难 2.全译码法除了片内寻址外的全部高位地址线都作为地址译码器的输入，输出作为各芯片的片选信号 优点：(1)每片芯片（或组）的地址范围是唯一确定的；而且是连续的，所以便于拓展，不会产生地址重叠的存储区 缺点：对译码电路要求较高 3.部分译码法除了片内寻址外的部分高位地址线作为地址译码器的输入，输出作为各芯片的片选信号 但由于只用到了部分的高位地址线，会出现地址重叠，例如CPU的地址线有20根，14根用作片内寻址，2根用来产生片选信号，则无论剩下的4根高位地址线取什么值，只要$A_{14},A_{15}$这两根确定了，选择芯片就确定了，造成了一个存储单元对应$2^{(20-16)}=2^4$个地址","path":"2021/12/03/计算机组成原理/第四章 存储系统/主存储器的连接与控制/","date":"12-03","excerpt":"","tags":[{"name":"存储系统","slug":"存储系统","permalink":"https://reiscarlet.github.io/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}]},{"title":"主存储器","text":"[toc] 1. 主存储器的组成和各部分的作用主存储器通常由存储体，地址译码驱动电路和读写电路 各部分的作用 存储体：是存储单元的集合 读写电路：包括读出放大器和写入电路，用来完成读写操作 地址译码驱动电路：在片选信号有效的情况下，把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读写电路的配合下完成对被选中单元的读写操作 2. 主存储器的存储单元存储字：二进制数作为一个整体存入或取出 存储单元（主存单元）：存放存储字或存储字节的主存储器空间 存储体：由大量的存储单元集合构成 地址：存储单元的编号 3. 主存储器的主要技术指标 存储容量 存取速度：直接决定整个计算机系统的运行速度 存取时间：存储器访问时间，指从启动一次存储器操作到完成该操作所经历的时间 存取周期：指连续启动两次访问存储操作所需间隔的最小时间 存储器带宽：单位时间内存储器所存取的信息量 价格 功耗 可靠性 集成度 性价比 4. 地址译码方式4.1 单译码法地址译码器只有一个，其输出称为字选线，用一根字选择线（字线），直接选中一个存储单元(某一行)的所有位，矩阵的每一行对应一个字。 例如：如果某个芯片有16个存储单元，每个存储单元有8位，这样就构成16*8行的矩阵。16个存储单元需要4个地址线。4个地址线经过译码就产生16个字线，16个字线对应16个存储单元。这样送过来的地址经过译码后就转变为字线上对应的有效电平，如地址0000译码对应的0号字线，0100对应的就是4号字线。这样就能对选中的存储单元进行读写操作 优点：结构简单 缺点：成本昂贵，只适合容量不大的存储器 4.2 双译码法地址译码器分为行译码器（X）和列译码器（Y）。把n位地址线分为接近相等的两部分，分别进行译码。得到行选择线X和列选择线Y，分别对应同一行的所有单元和同一列的所有单元，行与列都确定后也就确定一个存储单元。","path":"2021/12/03/计算机组成原理/第四章 存储系统/主存储器/","date":"12-03","excerpt":"","tags":[{"name":"存储系统","slug":"存储系统","permalink":"https://reiscarlet.github.io/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}]},{"title":"微程序控制器","text":"[TOC] 1. 基本术语 微命令和微操作： 一条机器指令可以分解成一个微操作序列 在微操作控制计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，是构成控制序列的最小单元 微命令和微操作是一一对应的。微命令是微操作的控制及信号，微操作是微命令的操作执行过程. **产生微操作控制信号的条件：时序信号，操作码译码信号，各部件状态的反馈信号** 微指令和微地址： 微指令是控制存储器中的一个单元的内容，即控制字，是若干个微命令的集合。存放控制字的控制存储器的单元地址就称为微地址 一个微指令包括 操作控制字段：产生某一步微操作所需的一系列微操作控制信号（微命令） 顺序控制字段：控制产生下一条要执行的微指令地址 微程序 一系列微指令的有序集合就是微程序。每一个机器指令都对应一个微程序，即一条机器指令能分解为若干条有序微指令 机器指令的执行实际上变成微指令的执行过程 微周期 从控制存储器中读取一条微指令并执行相应的微命令所需的全部时间称为微周期 2.微程序控制器的组成微程序控制器组成有： 程序计数器PC 指令寄存器IR 控制存储器部件CM（常用ROM实现，用于存储微程序控制器的全部微程序） 微指令寄存器μIR（用来保存从控制存储器中读取的一条微指令） 下地址形成逻辑（形成并提供出下一次要用到的微指令在控制存储器中的地址），产生的微地址被存放到微地址寄存器中μMAR，为在控制存储器中读取微指令做准备 3.微程序控制器的工作过程取指令的公共操作通常由一个取值微程序来完成 执行取指令的公共操作，将指令取到指令寄存器IR 机器开始运行时，自动将取值微程序的入口微地址送μMAR 从CM中读出微指令送入μIR 微指令的操作控制字段产生有关的微命令，用来控制计算机实现取机器指令的公共操作 当取指微程序执行完后，从主存取出的机器指令就已存入指令寄存器中 由机器指令（IR中的指令）的操作码字段产生该机器指令对应的微程序的入口地址，送入μMAR 从CM中逐条取出对应的微指令并执行 执行完对应于一条机器指令的一个微程序后又回到取值微程序的入口地址 4.微指令的编码方式微指令的编码方式指的是操作控制字段的编码方式 直接控制方式 每一个微命令都用一个确定的二进制位予以表示 最短编码方式 使每一条N位字长的微指令只定义一个微命令 M个微命令的二进制编码位：$N\\ge\\log_2 M$ 字段编码方式 字段直接编码方式：对微指令进行分段，每个字段独立编码，每种编码代表一个微命令 分段的原则 在同一节拍内，需要互相配合起作用的微操作是并行操作，其微命令可以分在不同的字段内，这是微命令的兼容性 在同一节拍内，不允许同时出现具有排他性的微操作，只能串行操作，其微命令可分在同一字段内，这是微命令的互斥性 应与数据通路结构相适应 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂度和译码时间 每个小段内留出一个状态，表示本字段不发出任何微命令 字段间接编码 无论什么编码方式，其追求目标都是：提高编码效率，压缩微指令字的长度；保持微命令必须的并行性；硬件线路尽可能简单 5.微程序流的控制5.1 得到下一条微指令地址微程序执行时，只要依次给出各个微指令的地址，就能使微程序连续执行，直至完成为止 要保证微指令逐条连续地执行，就必须在本条微指令地执行过程中，能取来或临时形成下一条微指令地地址 每条机器指令均有一道于其对应地微程序，微程序的执行顺序的控制，是通过指定微指令的微地址来进行的 ## 5.2.微程序入口地址的形成 当公用的取指微程序从主存储器中取出机器指令后，由机器指令的操作码字段指出各个微程序的入口地址，由机器指令的操作码转换成初始微地址的方式有3种 1. 一级功能转换：如果机器指令操作码字段的位数和位置固定，可以直接使操作码与入口为地址码的部分位相对应 二级功能转换：当同类机器指令的操作码字段的位数和位置固定，而不同类机器指令的操作码的位数和位置不固定时，采用二级功能转换时使用二级功能转换。 过程：第一次先按指令类型标志转移，以区分出指令属于哪一类。第二次按操作码区分出具体是哪条指令，以便找出微程序的入口微地址 通过PLA电路实现功能转换：当机器指令的操作码位数和位置都不固定时，采用PLA电路将每条机器指令的操作码翻译成对应的微程序入口地址","path":"2021/12/03/计算机组成原理/第五章 中央处理器/微程序控制器/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"中央处理器概念","text":"[TOC] 1.CPU的功能功能：对指令流和数据流组成的信息流在时间、空间上实现正常控制 2.CPU的组成2.1 控制器2.1.1 控制器的功能 取指令 指令译码 控制指令执行 控制程序和数据的输入与结果溢出 处理异常情况和请求 2.1.2 控制器的组成 指令部件 指令部件包括程序计数器、指令寄存器、指令译码器和地址形成不见 地址形成部件：根据指令的不同寻址方式，形成操作数的有效地址 时序部件 时序部件包括脉冲源、启停控制逻辑和节拍信号发生器 启停控制逻辑：只有通过启停控制逻辑将计算机启动后，主时钟脉冲才允许进入，并启动节拍信号发生器 节拍信号发生器：经过节拍信号发生器后产生出各个机器周期中的节拍信号，用以控制计算机完成每一步微操作 微操作信号发生器 微操作：最基本的不可分割的操作称为微操作。微操作信号发生器也称控制单元CU。不同的机器指令具有不同的微操作序列 中断控制逻辑 用来控制中断处理的硬件逻辑 2.1.3 控制器的分类 组合逻辑控制器（硬部件控制器） 优点：速度快 缺点：调试、维修较为困难，难以实现自动化；一旦控制部件构成后，要想增加新的控制功能几乎不可能 存储逻辑控制器（微程序控制器） 优点：具有设计规整、调试、维修、更改以及扩充指令方便，易于实现自动化设计 缺点：指令的执行速度比组合逻辑控制器慢 组合逻辑和存储逻辑结合型控制器（可编程逻辑阵列控制器，PLA） PLA控制器克服了两者的缺点 控制器的实现方式可以不同，但是产生微操作控制信号的功能是相同的 产生微操作控制的条件都是：时序信号，操作码译码信号和被控制部件的反馈信号等综合而成 2.2 运算器 执行所有的算术运算 执行所有的逻辑运算，并进行逻辑测试 3.CPU的五个专用寄存器 指令寄存器：存放当前计算机正在执行的指令，直至该指令被执行完毕 程序计数器：读取指令的地址，或以成秀计数器的内容为基准计算操作数地址。当现行指令执行完毕时，通常由程序计数器提供下一条要执行的指令的地址 程序状态字寄存器：存放程序状态字。程序状态字的各位表征算数或逻辑指令运行或测试的结果建立的各种状态和条件信息以及系统状态和中断信息等 存储器地址寄存器：保存当前CPU所访问的主存储器单元地址 存储器数据寄存器：用来暂时存放由主存储器读出的一条指令或一个数据字 4.时序系统与控制方式4.1 时序系统 指令周期 读取并执行一条指令所需的时间称为一个指令周期 不同指令的指令周期是不完全相同的 机器周期 机器周期又称CPU周期；一般把一个指令周期划分为若干个机器周期，每个机器周期完成一个基本操作 一般CPU周期有：取指周期、取数周期、执行周期和中断周期等 取指周期完成三件事：从内存中取出指令；将PC的内容递增，为取下一个指令做准备；对指令操作码进行译码或测试，以确定执行哪一些微操作 非访内指令： 一般需要2个CPU周期：取指周期、执行周期 直接访内指令 一般需要3个CPU周期 第一个CPU周期取出指令 第二个CPU周期将操作数地址送往地址寄存器并完成地址译码，得到操作数 第三个CPU周期取出操作数并进行运算 间接访内指令 一般需要4个CPU周期 第一个CPU周期取出指令 第二个CPU周期将操作数地址送往地址寄存器并完成地址译码，得到操作数地址 第三个CPU周期取出操作数地址，再进行地址译码，得到操作数 第四个CPU周期去除操作数并进行运算 程序控制指令 一般需要2个CPU周期 第一个CPU周期取出指令 第二个CPU周期向PC送一个目标地址，使下一条指令不再是这一条指令的下一条指令，实现指令执行顺序的跳转 时钟周期（节拍） 把一个机器周期分成若干相等的时间段，每一个时间段内完成一步操作，这个时间段即为时间周期，又称节拍 脉冲 有的操作还需要严格的定时脉冲，以确定在哪一时刻写入 4.2 控制方式 同步控制方式 同步控制方式中，每个周期状态中产生统一数目的节拍电位和工作脉冲 优点：同步控制方式设计简单，操作控制容易实现。 缺点：会有较多的空闲节拍和空闲工作脉冲，形成较大数量的时间浪费，影响和降低执行执行的速度 异步控制方式 按每个指令、操作的时间需要而占用时间的一种控制方式。 通常由前一操作执行完毕时产生的结束信号，或由下一操作的执行部件发出就绪信号作为下一操作的起始信号 优点：效率高 缺点：硬件实现复杂 5. 指令运行基本过程 取指令与公共操作 取指令阶段完成的任务是将现行指令从主存储器中取出送到指令寄存器IR中 将程序计数器PC提供的地址送往存储器地址寄存器MAR，并送地址总线AB 向存储器发读命令 将读取的现行指令通过数据总线DB送到存储器数据寄存器MDR，然后再送到指令寄存器中，用符号表示为：IR-&gt;((PC)) 将PC的内容递增，为取下一条指令做好准备","path":"2021/12/03/计算机组成原理/第五章 中央处理器/中央处理器/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数据校验码","text":"[toc] 数据校验码1.什么是错误$1$变成$0$，$0$变成$1$ 2.什么样的编码具有检错纠错能力**码距**：任意两个码字之间最少变化的二进制位数 具有检错纠错能力的数据校验码的实现原理是：在编码中，除去合法的码字，再加进一些非法的码字，当某个合法的码字出现错误时，就变成非法码字 **对于码距≥2的数据校验码，开始具有检错能力，码距越大，检、纠错能力就越强，而且检错能力总大于或等于纠错能力** 3.如何发现错误奇偶校验码校验位的取值（0或1）将使得整个校验码中”1”的个数为奇数或偶数： 奇校验——使得整个校验码中”1”的个数为奇数 偶校验——使得整个校验码中”1”的个数为偶数 交叉奇偶校验：传送数据块时，不仅每个字节有一个奇偶校验做横向校验，而且全部字节的同一位也设置一个奇偶校验做纵向校验 例如，对于二进制数1000011，奇校验码为10000110，偶校验码为10000111 判断是否出错：E=校验码各位的异或得到的结果；对于奇校验E=1时编码正确，而偶校验则是E=0时编码正确 纠错能力：奇偶检验只能发现奇数个位的错误，不能定位出错点 ## 4. 如何确定错误的位置 ### 海明校验码 校验位K，信息位N，则$2^{K+1} \\ge N+K+1 $ (1)编码 一个字节由8位二进制位组成，此时N=8， K=5，故海明码总位数为N+K=13，表示为：$H_{13}\\ H_{12}...H_{2}\\ H_{1}$ 五个校验位$P_5~P_1$对应的海明码位为:$H_{13}、H_{8}、H_{4}、H_{2}、H_{1}$,除$P_5$外其余四位满足$P_i中i等于2^{i-1}$的关系，而$P_5$只能放在$H_{13}$ P_1校验的是$D_1、D_2、D_4、D_5、D_7$，对应的海明码为$H_1(1),H_5(4+1),H_7(4+2+1),H_9(8+1),H_{11}(8+2+1)$,化位二进制就会发现，都有一个$XXXXXXX1$的形式，也就是说$P_i$校验的是二进制中权值为i的位数值为1的那些位数$(D_{位数})$,P2,P3,P4,P5同理 则$P_1=D_1\\oplus D_2\\oplus D_4\\oplus D_5\\oplus D_7$，用同样的方法将其他$P_i$求出 (2)校验 将接收到的海明码按如下关系进行偶校验： 如右所示：$S_1=P_1\\oplus D_1\\oplus D_2\\oplus D_4\\oplus D_5\\oplus D_7$ ，即将$P_1$和对应的$D_i$进行异或算出结国 然后依次求出$S_2\\ S_3\\ S_4\\ S_5$ ① 如果$S_5 \\sim S_1为00000$时，表明无错 ② 如果$S_5 \\sim S_1$仅有一位不为$0$，表明是某一位校验位出错或三位海明码同时出错 ③ 如果$S_5 \\sim S_1 $有两位不为$0$，表明是两位海明码同时出错，但无法确定出错位置 ④ 如果$S_5 \\sim S_1$有三位不为$0$，表明是一位信息位出错或三位校验位同时出错，出错位置由$S_4 \\sim S_1 $四位编码指明","path":"2021/12/03/计算机组成原理/第二章 运算方法和运算器/数据校验码/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数值数据的表示方法","text":"[toc] 1. 原码表示法$[X]_原 = \\left\\{\\begin{aligned}\\begin{equation} X,\\qquad 2^n &gt; X\\ge 0 \\\\ 2^n-X, 0\\ge X&gt;-2^n \\end{equation}\\end{aligned} \\right.$ 其中n为小数点前的位数，小数时n=0 2. 补码表示法模：一个字长为n+1位的纯整数的溢出量为$2^{n+1}$，即是以$2^{n+1}$模。一个纯小数的溢出量为2 同余：两个整数A，B除于同一个整数M，所得余数相同，称A和B对模M同余 只要确定了一个模，就可以找到一个与负数等价的正数来替代此负数，而这个正数可以用模加上负数本身求得，这样就可把减法运算用加法实现了 $[X]_补 =\\left\\{\\begin{aligned}\\begin{equation} X,\\qquad\\qquad 1 &gt; X \\ge 0 \\\\ 2^{n+1} + X,\\quad 0 &gt; X \\ge -1(mod2) \\end{equation}\\end{aligned}\\right.$ 小数n=0 补码快捷方式：数值部分按位取反，末尾加1，符号位不变 表示范围：字长为n+1位的机器，补码定点整数表示范围是$-2^n\\sim2^n-1$. 定点小数的-1补码表示为1.0000. # 3. 定点表示法 小数点的位置固定为最高有效位之前，符号位之后，记为$X_s.X_1X_2...X_n$ 定点小数的小数点位置是隐含约定的，并不需要真正的占据一个二进制位 当$X_s = 0$ 由$.X_1X_2...X_n$都为1时为最大正数 **定点小数的最大正数为**：$X_{最大正数} = (1 - 2^{-n})$ 由$.X_1X_2...X_n都为0时为最小正数$ **定点小数的最小正小数为**：$ X_{最小正数}=2^{-n}$ --- 当$X_s = 1$ 原码表示中由$.X_1X_2...X_n都为1时为最小负数$ 原码表示定点小数最小负数为：$X_{最小负数} = -(1-2^{-n})$ 补码表示中由$.X_1X_2...X_n$都为0时为最小负数 补码表示定点小数的最小负数为：$X_{最大负数} = -1$ 整数和上面同理 在这里，为什么最大负数为-1？，在补码中，零具有唯一确定性，补码比原码少一个-0的表示，多一个-1的表示以及整数表示范围多了一个$-2^{n}$ 4. 移码由于补码很难直接判断真值大小，因为如果一个负数和正数比较会出现$[+21]_{补}=010101$和$[-21]_{补}=101011$比较出现$010101$小于$101011$的结果，然而实际上真值是$+21$大于$-21$，此时我们可以将所有的数往正数方向偏移一定的量，使得负数为正，再来比较数值的就不会出错 $[X]_{移} = 2^n + X(2^n&gt;X\\ge -2^n)$ $[X]_{移} = [X]_{补} + 2^n$ 移码的表示范围：机器字长为n+1的计算机，移码定点整数的表示范围为$-2^n\\sim(2^n-1)$ 移码与补码：真值部分相同，最高位相反 5. 浮点数的表示方法二进制N的浮点数的一般表示为$N=M*2^E$，其中E为阶码（用二进制数表示），M为尾数或有效位 浮点数的机器码表示 S(尾数M的符号位) E_f（阶码E的符号位） E（阶码） M（尾数） 5.1 规格化浮点数 浮点数的基数为2，如果位数满足$2^{-1}\\le|M|&lt;1$，则称该浮点数为规格化浮点数 例如：十进制数-78，求它的规格化浮点数 $(-78)_{10}=(-1001110)_2 = -0.1001110*2^7$ 则它的规格化浮点数为$-0.1001110*2^{111}$ 如果阶码用移码5位表示，则$[+111] = [10000 + 111]_{移码}=[10111]移码$,其中阶码为0111，符号位为1 尾数用补码表示，且浮点数机器码共16位，则$[-0.1001110000]=[1.0110010000]_{补码}$，其中尾数0110010000，符号位为1 则规格化机器码表示为1\\1\\0111\\0110010000","path":"2021/12/03/计算机组成原理/第二章 运算方法和运算器/数值数据的表示方法/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"定点数的加减法","text":"[toc] 1. 变补：$[-Y]_{补}$被称为$[Y]_{补}$的机器负数，由$[Y]_{补}求[-Y]_{补}$的过程称为对[Y]补的变补 表示为：$[-Y]_{补} = [[Y]_{补}]_{变 补}$ 2. 补码与变补的区别一个负数由原码转换为补码时，符号位是不变的，仅对数值求补，而变补则不论这个数的正值是正是负，一律连同符号位取反，末位加1 在补码的加减法中，若做加法则两数直接相加，若做减法，则将被减数与减数的机器负数相加，运算结果用补码表示 表示为$[X]_{补} - [Y]_{补} = [X]_{补} + [-Y]_{补} = [X]_{补} + [[Y]_{补}]_{变 补}$ 注意：最后答案要写出真值，除非题目写了求的是补码等 3. 溢出若X，Y异号，不会溢出 若X，Y同号，运算结果超出所能表示的范围是，溢出，大于最大正数称为正溢，小于最小负数称之为负溢 3.1 检测溢出3.1.1 单符号位：当两个同号的数值进行加减操作后，所得到的结果的符号位与之不同时，则发生了溢出。 缺点：如果符号位的后一位在运算过后产生了进位，可能会影响检测溢出结果的正确性 3.1.2 采用进位位在考虑了进位对符号位的影响后，进行改进得到的 如果符号位产生进位而最高有效位没有进位时，发生负溢 如果符号位没有进位，而最高有效位发生进位时，发生正溢 3.1.3 采用变形补码(双符号位补码)双符号位的含义如下： $S_{S1}S_{S2}=00$,结果为正数，无溢出 $S_{S1}S_{S2}=01$,正溢 $S_{S1}S_{S2}=10$,负溢 $S_{S1}S_{S2}=11$,结果为负数，无溢出","path":"2021/12/03/计算机组成原理/第二章 运算方法和运算器/定点数的加减法/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"定点数的乘、除法运算","text":"[toc] 移位分为算术移位，逻辑移位和循环移位三类，它们又可以分为左移和右移 1. 算术移位规则原码的移位规则：负数的原码移位后的空出位补0 补码的移位规则： 负数的补码左移后的空出位补0 负数的补码右移后的空出位补1 移位功能的实现：通过移位操作由移位寄存器来实现，也有在加法器的输出的加一个实现直传、左移一位和右移一位的控制逻辑电路（称为移位器） 2. 定点乘法运算2.1 原码一位乘法 参加运算的操作数取其绝对值 令乘数的最低位为判断位 若为1，加被乘数 若为0，不加被乘数 累加后的部分积右移一位（这里是逻辑移位） 重复n次2，3步 符号位单独处理，同号为正，异号为负 例题： 已知：X=0.1101, Y=-0.1011, 求X*Y \\\\ |X| = 00.1101 \\rightarrow B, \\\\ |Y| = .1011 \\rightarrow C, 0 \\rightarrow A \\\\ 2. 2 补码一位乘法2.2.1 校正法 被乘数任意，乘数为正：同原码乘，但加和移位按补码规则运算，乘积的符号自然形成 被乘数任意，乘数为负：乘数$[Y]_{补}$，去掉符号位，操作同①，最后加$[-X]_{补}$，校正 2.2.2 Booth算法以小数为例子： 设$[X]_补 = X_s.X_1X_2…X_n\\quad[Y]_补=Y_S.Y_1Y_2…Y_n$ $[X*Y]_补 $ $ = [X]_补(0.Y_1Y_2…Y_n) - [X]_补 * Y_s$ $=[X]_补(Y_12^{-1}+Y_22^{-2}+…+Y_n2^{-n}) - [X]_补*Y_s$ $=[X]_补\\ (-Y_s + Y_12^{-1} + Y_22^{-2} + … + Y_n2^{-n})$ $=[X]_补=[-Y_s + (Y_1 - Y_12^{-1}) + (Y_22^{-1} - Y_22^{-2}) + … + (Y_n2^{-(n-1)}-Y_n2^{-n})]$ $=[X]_补 = [(Y_1-Y_s) + (Y_2 - Y_1)2^{-1} + … + (Y_n - Y_{n-1}2^{-(n-1)}) + (0 - Y_n)2^{-n}]$ 递推公式： [Z_0]_补 = 0\\\\ [Z_1]_补 = 2^{-1}\\{[Z_0]_补 + (Y_{n+1}-Y_{n})[X]_补\\}\\\\ [Z_2]_补 = 2^{-1}\\{[Z_1]_补 + (Y_{n}-Y_{n-1})[X]_补\\}\\\\ ...\\\\ [Z_n]_补 = 2^{-1}\\{[Z_n-1]_补 + (Y_{2}-Y_{1})[X]_补\\}\\\\ \\therefore [X*Y]_补 = [Z_n]_补 + (Y_1 - Y_s)[X]_补其中，$[Z_0]_补$为初始部分积，$[Z_1]_补\\sim[Z_n]_补$依次为各次求得的累加并右移之后的部分积 描述：对于乘数$[Y]_补 = Y_1Y_2…Y_n$,被乘数$[X]_补=X_1X_2….X_n$，即乘数、被乘数都用补码表示，得到的结果也是补码的形式 若乘数当前位为1，下一位为0，则用部分积减去乘数，得到新的部分积 若乘数当前位为0，下一位为1，则用部分积加上乘数，得到新的部分积 若乘数当前位与下一位相同，则什么都不做 上诉操作后按照补码规则右移 注意事项： 当被乘数与部分积相加时，产生的进位将被丢弃 部分积移位时，使用算数移位，最高位补符号位 乘法开始时，乘数的当前位（n）为其最低位，下一位（n+1）为0 3. 定点数的除法运算3.1 原码恢复余数法步骤： 将除数的最高位与被除数的最高位对齐 从部分被除数中减去除数，得到新的部分被除数 若新的部分被除数为负，则商左移一位，最低位补0，并用新的部分被除数加上除数，恢复原先的部分被除数 若新的部分被除数为正，则商左移一位，最低位补1 判断除法是否结束。若除数的最低位与部分被除数的最低位对齐，则除法结束。最后的部分被除数就是余数 将除数右移1位，从第②步继续执行 原码恢复余数法在计算机中一般很少采用 3.2 原码不恢复余数除法(加减交替法)和原码恢复余数除法的区别是： 若新的部分被除数为正，商左移一位，最低位补1，部分被除数减去除数 先对除数进行右移再判断新的部分被除数为正为负 例题： 假设X=-0.10101,Y=0.11110,求X\\div Y\\\\ 预先准备:\\\\ |X|=00.10101 \\rightarrow A \\\\ |Y|=00.11110 \\rightarrow B \\\\ 0 \\rightarrow C \\\\ [-|Y|]_{补}=[|Y|]_{变补} = 11.00010","path":"2021/12/03/计算机组成原理/第二章 运算方法和运算器/定点数的乘法运算/","date":"12-03","excerpt":"[toc] 移位分为算术移位，逻辑移位和循环移位三类，它们又可以分为左移和右移","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"指令系统","text":"[toc] 一.指令系统的发展与性能要求一个好的指令系统一般满足以下几个要求： 完备性 规整性 高效率 兼容性 一条指令一般提供两方面的信息 指明操作的**性质**及**功能** 给出与操作数有关的信息，如直接给出操作数本身或是指明操作数的来源，运算结果存放在何处，以及下一条指令从何处取得等。 二.指令格式 操作码字段OP 地址码字段A 2.1 指令字长在设计指令格式时需要考虑以下一些问题： 指令字长需要多少位，是定子长还是变字长 操作码结果需要多少位，位数与位置固定还是可拓展；是一段操作码还是由若干段组成 地址结构——一条指令的执行涉及那些地址，在指令中给出了哪些地址，哪些地址是隐含约定的 寻址方式——如何获得操作数地址，是直接给出还是间接给出，还是经过变址计算所得等 机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。 指令字长：一个指令中包含二进制代码的位数。 存储字长：一个存储单元存储二进制代码的长度，必须是字节的整数倍 指令字长的选择： 指令字长尽可能短 指令字长应等于字节的整数倍，以免浪费存储空间 指令字长一般都取存储字长的整数倍，如果指令字长等于存储字长的2倍，就需要2次访存来取出一条指令，因此取指周期是机器周期的2倍，若指令周期等于存储字长，则取指周期等于机器周期。 2.2 指令的操作码指令操作码的编码可以分为规整型和非规整型 2.2.1 规整型​ 当指令字长较长时，允许有足够的操作码位数，可以采取定长编码方式。 ​ 定长编码对于简化硬件设计，减少指令译码的时间是非常有利的，通常在指令字长较长的大型、中型计算机就及超级小型计算机上广泛采用 2.2.2 非规整型​ 拓展操作码法：操作码位数不采用单一固定不变的位数，而是随地址码个数的变化而变化，操作码采取可变长度的类型 ​ 拓展操作码的注意点： 不允许短码是长码的前缀 各条指令的操作码一定不能重复雷同 各类指令的格式安排应统一规整 2.3 地址码的结构显地址：在指令中明显给出地址，如写明存储单元号或寄存器号 隐地址：以隐含的方式约定，如事先隐含约定操作数在某个寄存器中，或是在堆栈中 四地址指令 $(A_1) OP(A_2)\\rightarrow A_3 \\\\ A_4 = 下一条执行指令的地址$ 三地址指令 $(A_1)OP(A_2)\\rightarrow A_3 \\\\ (PC)+1\\rightarrow PC(隐含)$ 执行一条三地址的双操作数运算指令，至少需要访问4次主存储器。第一次取指令本身，第二次取第一操作数，第三次取第二操作数，第四次保存运算结果 二地址指令 $(A_1)OP(A_2)\\rightarrow A_1 \\\\ (PC)+1\\rightarrow PC(隐含)$ 同样需要至少访问四次主存储器 一地址指令 $(AC)OP(A_1)\\rightarrow AC \\\\ (PC)+1\\rightarrow PC(隐含)$ AC为累加寄存器 执行一条一地址的双操作数运算指令，只需要访问2次主存储器。第一次取指令本身，第二次取第一操作数。第二操作数和运算结果都放在AC中，所以读取和存入都不需要访问主存储器 零地址指令 零地址的算数逻辑类指令用在堆栈计算机中的，堆栈计算机没有一般计算机中必备的通用寄存器，因此 存储器——存储器(SS)型指令 寄存器——寄存器(RR)型指令 寄存器——存储器(SR)型指令 通常一个指令系统中指令字的长度和指令中的地址结构并不是单一的，往往采用多种格式混合使用，这样可以增强指令的功能 三.寻址技术3.1 编制方式编制方式：对各种存储设备进行编码的方法 常用的编制单位：字编址，字节编址，位编址等 3.1.1 字编址 控制方式实现简单，地址信息，存储容量等没有任何浪费 缺点是没有对非数值计算提供支持，而非数值计算应用要求按字节编码，因为它的基本寻址单位是字节 3.1.2 字节编址 最大优点：能使编制单位与信息的基本单位（字节）相一致 存在着地址信息的浪费 3.2 指令的寻址方式在存储器中，操作数或指令字写入或读出的方式可分为：地址指定方式，相联存储方式和堆栈存取方式 寻址方式分为两类：指令寻址方式和数据寻址方式 寻找下一条将要执行的指令的地址成为指令寻址，又可以细分为顺序寻址和跳跃寻址 顺序寻址方式：通过程序计算器PC加1，自动形成下一条指令的地址 跳跃寻址方式：所谓跳跃指的是下条指令的地址吗不是由程序计数器PC给出，而是由本条指令给出的 3.3 操作数的寻址方式操作数寻址方式：形成操作数的有效地址的方式 有效地址：是操作数在主存的地址或寄存器地址，是操作数真正的地址. 形式地址：指令字中给定的地址量。 寻址方式特征位，通常由间址位和变址位组成，如果这条指令无间址和变址的要求，那么形式地址就是操作数的有效地址 **寻址过程就是把操作数的形式地址变化为操作数的有效地址的过程** 数据寻址方式： 立即数寻址方式 指令的地址码字段指出的不是操作数的地址，而是操作数本身 例如：IF I &gt; 25 THEN J = K + 12,这里常量12和25均由立即数寻址指定 直接寻址方式 直接寻址方式： 操作数在主存储器中，指令中直接给出操作数所在主存储器单元的有效地址 寄存器（直接）寻址方式：操作数在指定的寄存器中 例如：ADD P, Q, R，表示将存储单元Q的内容与R的内容相加，并将结果保存在存储单元P中（ARM中的寻址可能不太一样） 间接寻址方式 间址方式：指令中给出的地址是存放操作数地址的主存储器单元的地址，可以有多级间址 寄存器间接寻址方式：地址字段指的是存储位置还是寄存器 指令地址字段中的形式地址A不是操作数的真正地址，而是操作数地址的指示器 获得一个操作数需要3次访问：读指令，读含有操作数地址的寄存器，以及最后读出实际的操作数 相对寻址方式 把程序计数器PC中的内容加上指令格式中的形式地址（偏移量）D形成操作数的有效地址。即是EA=(PC)+D 基址寻址方式 同相对地址，不过有效地址EA = [$R_i$]+D，其中Ri是基址寄存器，里面存放的是基准地址，D为指令地址码给出； 优点：扩大寻址能力，因为基址寄存器的位数可以设置得很长从而在较大得存储空间中寻址 变址寻址方式 通过将变址寄存器$R_x$的内容与形式地址相加来形成操作数的有效地址，即EA=($R_x$)+A 变址寻址和基址寻址的区别：基址寄存器提供的基准值是固定的，指令提供位移量是可变的；而变址寄存器提供的修改量是可变的，指令提供的位移量是固定的 堆栈寻址 在软堆栈中，堆栈的长度（堆栈中元素的数目）是可变的 在一般的计算机中，堆栈从高地址向低地址扩展，即栈底的地址总是大于或等于栈顶的地址（也有反过来的） 进行入栈操作时：先把堆栈指针SP（栈顶指示针）减量，然后把数据送入SP所指定单元 进行出栈操作时：先把SP所指的单元（栈顶）的数据取出，然后对SP增量 隐含寻址方式 不明显给出操作数的地址，而是在指令中隐含着操作数的地址，例如AC（累加寄存器） 四. 指令类型4.1 程序控制类指令 转移指令 无条件转移指令 条件转移指令 转子程序与程序返回指令 区别：转移指令无须返回，转子程序指令则需返回 通常用堆栈来保存返回地址 程序中断指令 一般作为隐指令 4.2 输入输出类指令对于统一编址方式的计算机，不需要设置专门的IO指令，用一般的数据传送类指针实现输入和输出 对于采用独立编址的计算机，则需要有专门的IO指令","path":"2021/12/03/计算机组成原理/第三章 指令系统/指令系统/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"通道方式","text":"[TOC] 1.通道的类型与结构1.1 通道的类型按照通道独立于主机的程度，可分为结合型通道和独立型通道两种类型 结合型通道在硬件结构上与CPU结合在一起，借助于CPU的某些部件作为通道部件来实现外部设备与主机的信息交换，这种通道结构简单，成本较低。但功能较弱 独立型通道完全独立于主机对外部设备及逆行管理和控制，这种通道功能强，但设备成本高 1.1.1 字节多路通道字节多路通道用于连接与管理多台低速设备，以字节交叉方式传送信息。字节多路通道的功能好比一个多路开关，交叉（轮流）地接通各台设备 一个字节多路通道，包括多个按字节方式传送信息地子通道。每个子通道服务于一个设备控制器，每个子通道可以独立地执行通道程序，各个子通道可以并行工作。但是，所有子通道地控制部分是公共的，各个子通道可以分时的使用 具有多路并行的能力 1.1.2 选择通道选择通道又称高速通道，在物理上也可以连接多个设备，但这些设备不能同时工作，在一段时间内通道只能选择一台设备进行数据传送，此时设备能独占整个通道。因此，选择通道一次只能执行一个通道程序 选择通道具有很高的数据传送数率，但整个通道的利用率不高 1.1.3 数组多路通道数组多路通道是把字节多路通道和选择通道的特点结合起来的一种通道结构 基本思想：当某设备进行数据传输时，通道只为该设备服务；当设备在执行辅助操作时，通道暂时断开与这个设备的连接，挂起该设备的通道程序，去为其他设备服务 既有多路并行操作的能力，又具有很高的数据传送速率，使通道的效率充分得到发挥 1.2 通道结构CSWR(Channel Status Word Register)、CAWR(Channel Address Word Register)和CCWR(Channel Command Word Register)是通道中3个重要的寄存器 CCWR是通道命令字寄存器，用来存放通道命令字CCW，CCW是控制I/O操作的关键参数，一条条的通道命令字构成通道程序，放在主存储器中 CAWR是通道地址字寄存器，指出CCW在内存中的地址，工作时通道就依照这个地址到主存储器中取出CCW并加以执行 CSWR是通道状态字寄存器，记录了通道程序执行后本通道和相应设备的各种状态信息，称为CSW，可供CPU了解通道、设备状态和操作结束的原因","path":"2021/12/03/计算机组成原理/第七章 输入输出系统/通道方式/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"输入输出接口","text":"[TOC] 1. 接口的概念因为主机与外部设备具有不同的工作特点，它们的工作速度相差一个或几个数量级；主机与外部设备的信息形式也是不同的，为此要设置I/O接口来解决这些差异，从而使主机和外部设备能够协同工作 2. 接口的作用 实现主机和外部设备的通信联络控制：接口中的同步控制电路用来解决主机与外部设备的时间配合问题 进行地址译码和设备选择：当CPU送来用来选择外部设备的地址码后，接口必须对地址进行译码，产生设备选择信息，使主机能和指定的外部设备交换信息 实现数据缓冲：在接口电路中，一般需要设置几个数据缓冲寄存器，用于数据暂存。在传输过程中，先将数据暂存到寄存器中，然后再送到输出设备或主机中 数据格式的转换：在输入输出操作中，为了满足主机或外部设备的各自要求，接口电路中必须具有完成各类数据相互转换的功能 传递控制命令和状态信息： 3. 接口的组成接口与端口：端口是指接口电路中可以进行读写的寄存器，若干个端口加上相应的控制逻辑电路才组成接口 一个接口包含有：数据端口，命令端口和状态端口。分别用来存放数据信息，控制命令和状态信息 4. 外部设备的识别为了在众多的外部设备中寻找出与主机进行信息交换的外部设备，必须对外部设备进行编址 独立编址方式：外部设备不占用主存单元。访问主存时由主存读写控制线控制，访问外部设备时，由IO读写控制线控制。需要单独设立I/O指令 统一编制方式：外部设备接口的寄存器相当于主存单元（占用主存单元？），CPU可以用访问主存单元的方法访问外部设备，不需要专门的I/O指令 5. 输入输出信息传递的控制方式 程序查询方式 是一种程序直接控制方式：由CPU执行一段输入输出程序来实现主机与外部设备之间的数据传送方式 过程：某一外部设备被选中并启动后，主机将查询这个外部设备的某些状态位，看齐是否准备就绪，如果就绪执行一次I/O操作，否则再次查询 优点：控制简单 缺点：外部设备和主机不能同时工作，各外部设备之间也不同同时工作、系统效率低 适用：CPU速度不高，外部设备的种类数目不多，数据传送率较低的情况 程序中断方式 过程：主机启动设备后，继续执行原来的程序，外部设备做好输入输出准备时，向主机发送中断请求，主机接到请求后暂时中止原来执行的程序，执行中断服务程序对外部请求进行处理，中断处理完毕后返回原来的程序继续执行 优点：允许主机和外部设备同时工作；允许一台主机管理台外部设备，使它们能同时工作 缺点： 对于高速外部设备，信息交换是成批的，如果处理不及时，可能会造成信息丢失； 外部设备较多时，中断请求频繁，导致CPU应接不暇； 适用：中、低速外部设备 直接存储器存取方式（DMA） 在主存储器和外部设备间开辟直接的数据通路，直接进行数据交换 优点：保证CPU的高效率，又能满足高速外部设备的需要 缺点：只能进行简单的数据传送操作，在数据块传送的起始和结束需要CPU及中断系统及逆行预处理和后处理 适用：高速外部设备 IO通道的控制方式 过程：系统中设有通道控制部件，每个通道挂若干个外部设备，主机执行IO操作时，只需要启动有关通道，通道将执行通道程序，从而完成IO操作 通道是一个具有特殊功能的处理机，但通道不是一个完全独立的处理机 优点：外部设备和通道可以并行同时工作，而且一个通道可以控制多台不同类型的设备 IO处理机方式 IO处理机基本上独立于主机工作","path":"2021/12/03/计算机组成原理/第七章 输入输出系统/输入输出接口/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"程序中断方式","text":"[TOC] 1.中断引入中断传送方式的思想是：CPU在程序中安排好在某一刻启动某一台外部设备，然后CPU继续执行原来的程序，一旦外部设备完成数据传送的准备工作，便主动向CPU发出一个中断请求，请求CPU为自己服务。在可以相应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为中断请求者服务，在中断服务程序中完成一次主机于外部设备之间的数据传送。传送完成后，CPU返回原来的程序，从断点处继续执行 2.中断请求和判优 中断请求的提出 由于每个中断源向CPU发出中断请求的时间是随机的，为了记录中断事件并区分不同的中断源，采用具有存储功能的触发器来记录中断源，称为中断请求触发器 多个中断请求触发器构成一个中断请求寄存器，中断请求寄存器的内容称为中断字或中断码，中断字为1表示对应的中断源有中断请求 中断请求的传送 独立请求线：每个中断源单独设置中断请求线将信号送往CPU 优点：CPU在节到中断请求的同时也就知道了中断源是谁，其中断服务程序的入口地址在哪里。有利于实现向量中断，提高中断的响应速度。 缺点：硬件代价较大，且CPU所能连接的请求线数目有限，难以扩充 公共请求线：多个中断源共有一条中断请求线 优点：中断源的数目可随意扩充 缺点：CPU接到中断请求后，必须通过软件或硬件方法识别中断源，然后再找出终端服务程序的入口地址 二维结构：同一优先级采用一根公共的请求先，不同请求线上的中断优先级不同 3.中断响应与处理3.1响应条件 CPU接收到中断请求信号 CPU允许中断 一条指令执行完毕：一般情况下，CPU会在一条指令执行完毕，且没有更急迫的任务时才能响应中断请求 3.2中断隐指令什么是中断隐指令：CPU响应中断之后，会经过某些操作，转去执行中断服务程序，这些操作是由硬件直接实现的，称为中断隐指令 中断隐指令完成哪些操作： 1. 保存断点：为了保证在中断服务程序执行完毕后能正确返回原来的程序，必须将原来程序的断点（程序计数器的内容）保存起来 2. 暂不允许中断：为了使在用软件保护中断现场时，不被新的中断被打断 3. 引出终端服务程序：实质就是取出中断服务程序的入口地址，送到程序计数器PC ## 3.3中断周期 1. 关中断 2. 修改栈指针 3. 断点进栈 4. 中断服务程序入口地址存入PC 5. 执行中断服务程序 # 4.允许禁止中断 允许中断和禁止中断是用CPU中的中断允许触发器控制 允许中断即是开中断，下列情况应开中断： > 1. 已响应中断请求转向中断服务程序，在保护完中断现场后，当中断允许触发器被置位有效位 > 2. 在中断服务程序执行完毕，将返回被中断程序之前，为能再次响应中断请求做准备 禁止中断即关中断，有下列情况应关中断： > 1. 当响应某一级中断请求，不再允许被其他中断请求打断时 > 2. 在中断服务程序的保护和恢复现场之前，使处理现场工作不至于被打断 # 5.中断屏蔽 中断源发出中断请求后，这个中断请求不一定能真的送到CPU中，在有些情况下，可以用程序方式有选择的封锁部分中断，这就是中断屏蔽 > 如果给每个中断源相应地配备一个中断屏蔽触发器，则每个中断请求信号在送往判优前还要受中断屏蔽触发器的控制，各中断屏蔽触发器组成一个中断屏蔽寄存器，其内容称为屏蔽字或屏蔽码，由程序来设置 具体来说，用程序设置的方法将中断屏蔽寄存器中的某一位置1，则对应的中断请求被封锁，无法参加排队判优；只有中断屏蔽寄存器中的某一位置为0，才允许中断请求送往CPU 6.中断升级 将原本级别较低的中断源变成较高的级别，称为中断升级 中断响应次序：由硬件排队电路决定，无法改变。 中断处理次序：可以由屏蔽码来改变 一般来说，屏蔽字中1越多，其优先级越高，屏蔽字按行看 7.程序中断处理过程 关中断：让CPU进入不可再次响应中断的过程 保存断点：将当前程序计数器中的内容保存起来 识别中断源，转向中断服务程序：在多个中断源同时请求中断的情况下，响应优先级最高的那个 保存现场，交换屏蔽字： 开中断：允许更高级的中断请求得到响应，实现中断嵌套 执行中断服务程序主体 关中断：为了在恢复现场和屏蔽字时不被中断打断 恢复现场和屏蔽字 开中断 中断返回","path":"2021/12/03/计算机组成原理/第七章 输入输出系统/程序中断方式/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"计算机系统概论","text":"[TOC] 1. 计算机硬件1.1 冯诺依曼思想 采用二进制形式表示数据和指令，指令由操作码和地址码组成 将程序和数据存放在存储器中，使得计算机在工作时从存储器取出指令加以执行，自动完成计算任务。这就是存储程序和程序控制，即存储程序控制的概念 指令的执行是顺序的，程序分支由转移指令实现 计算机由存储器，运算器，控制器、输入设备和输出设备五大基本部件组成 1.2 冯诺依曼结构的特点 （1）单处理机结构，机器以运算器为中心；（2）存储程序控制；（3）指令和数据一样可以参与运算；（4） 数据以二进制表示；（5）将软件和硬件完全分离；（6） 指令由操作码和操作数组成；（7）指令顺序执行。 1.3 中央处理器、主机、外设的概念主机：主存储器、运算器和控制器在信息处理中起主要作用，是计算机硬件的主体部分，称为主机 外设：主机以外的硬件装置，如输入输出设备等，统称为外部设备，简称外设 中央处理器：运算器和控制器是信息处理的中心部件，称为中央处理器 1.4 微型计算机硬件微型计算机：通过地址总线、数据总线和控制总线这三类总线把各个部分组织在一起 数据总线： 双向总线，在不同时刻可以在不同方向上传输数据，但在同一时刻只能在一个方向上传输数据 地址总线：用来选择发送数据或接收数据的地址 控制总线：不是双向总线，在大多数情况下，任何一条控制总线上的信息总是在一个方向上传输 # 2. 计算机系统 ## 2.1 计算机系统层次 - 硬件系统： 1. 数字逻辑层 2. 微体系结构层 - 介于硬件与软件间： 3. 指令系统层 - 软件系统 4. 操作系统层 5. 汇编语言层 6. 高级语言层 7. 应用层 **第一层到第三层是由硬件或固件构成的实际机器层，第四到第七层是软件模拟出来的虚拟机器层** ## 2.2 软件与硬件的关系 逻辑等价：有许多功能可以直接由硬件实现，也可以在硬件支持下靠软件实现，对用户来说在功能上是等价的，称为软、硬件在功能上的逻辑等价 固件化：采用微程序控制技术使计算机的结构和硬、软件功能分配发生变化，对指令的解释和执行是通过运行微程序来完成的 3. 性能指标 主频 机器字长：计算机中参与运算的数据的基本位数。机器字长是计算机CPU硬件组织的基本单位 运算速度 主存容量 可靠性 可维护性 可用性","path":"2021/12/03/计算机组成原理/第一章 计算机系统概论/计算机系统概论/","date":"12-03","excerpt":"","tags":[{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"","text":"","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/进程通信与端口号/","date":"12-03","excerpt":"","tags":[]},{"title":"VPN，NAT","text":"VPNVirtual Private Network，虚拟专用网 定义：利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网称为虚拟专用网 专用（私有）地址： 10.0.0.0 ~ 10.255.255.255(10/8地址块) 172.16.0.0 ~ 172.31.255.255 (172.16/12地址块) 192.168.0.0 ~ 192.168.255.255(192.168/16地址块) 虚拟专用网的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址 私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信，私有地址只能用作本地地址而不能用作全球地址 对于因特网上的路由器，目的地址是私有地址的IP数据报一律不进行转发 VPN要保证数据的安全性，会将原始的内部数据进行加密，然后再将其封装成为在因特网上发送的外部数据报 VPN的类型 同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN 有时同一机构的VPN需要有某些外部机构参加进来，这样的VPN称为外联网VPN 在外地工作的员工需要访问公司内部的专用网络时，只要在任何地址接入因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源，这种VPN称为远程接入VPN NATNetwork Address Translation，网络地址转换 NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源 当一个专用网中的主机向一个全球IP地址的主机发送数据报，数据报发送到NAT路由器，源地址一开始记录的是该主机的私有地址，目的地址字段的值为另一台主机的全球IP地址。 NAT从自己的全球IP地址池中为该主机分配一个临时的全球IP地址，此时源地址字段的值为临时全球IP地址，然后NAT将私有地址与全球地址的关系记录在转换表中，然后就可以转发改数据报了 如果是一个全球IP地址的主机向专用网的私有地址的主机发送数据报，在NAT的转换表中查找目的地址中的全球IP地址对应在专用网上的私有地址，然后将目的地址改写成该私有地址再进行数据报的转发 该转换方式存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上主机通信 解决办法：由于绝大多数网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换 这样，用一个全球IP地址就可以使用多个拥有本地地址的主机和因特网上的主机进行通信，这种将端口号和IP地址一起进行 转换的技术叫做网络地址与端口号转换NAPT（Network Address and Port Translation） 注意：不能由外网主机首先跟内网主机进行通信，因为此时NAT转换表中还没有映射关系 由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/VPN和NAT/","date":"12-03","excerpt":"","tags":[{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"TCP","text":"[TOC] 一、TCP协议的主要特点 支持面对连接的传输服务 支持全双工通信 支持同时建立多个并发的TCP连接 支持可靠的传输服务 支持字节流的传输 二、TCP报文的首部格式 序号：指出本TCP报文段数据载荷的第一个字节的序号 确认号：指出希望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认 数据偏移：4比特，最大表示154字节。*用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远&lt;/u&gt; 校验和：在计算校验和时候，要在TCP报文段的前面加上12字节的伪首部 复位标识符RST：用来复位TCP连接 当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。 RST=1还能用来拒绝一个非法的报文段或拒绝打开一个TCP连接 紧急指针：占16比特，用来指明紧急数据的长度。当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立即封装到一个TCP报文段中进行发送 选项： 最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度 窗口扩大选项 时间戳选项： 用来计算往返时间RTT 用来处理序号超范围的情况，又称为防止序号绕回PAWS 选择确认选项 填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除，因为数据偏移字段是以4字节为单位 TCP连接的三个阶段： 建立TCP连接 数据传送 释放TCP连接 三、TCP连接的建立TCP连接的建立需要解决的三个问题： 使TCP双方能够确认对方的存在 使TCP双方能够协商一些参数 使TCP双方能够对运输实体资源进行分配 TCP使用”三次握手“建立连接 为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？假设我们改为“两次握手”来建立TCP的连接，则可能出现一种情况。如果上一次的TCP连接请求因为各种原因延迟到达，在这期间，客户端又发起一次TCP连接请求，并建立连接。在进行数据传输后释放了连接。结果在这段时间延迟的TCP连接请求已经失效，但上一次延迟的TCP连接可能才到达，并且服务器向客户端发送报文并处于连接已建立的状态，而客户端因为没有再发送连接请求，所以不会理会该报文。此时就出现客户端处于未连接状态，而服务器端处于连接状态。 如果是“三次握手”，因为多了一步连接确认报文。TCP连接请求失效后，收到服务器端发送的报文，将不会理会。服务器端因为没有接收到报文，则连接无法建立！ 四、TCP连接的释放 1. 注意点：当服务器端发送TCP确认报文段后，服务器端的TCP连接将会断开，然后再向客户端发送TCP释放请求，而不是整个过程结束后客户端和服务器端一起断开连接。 MSL（Maximum Segment Lifetime）：最长报文段寿命，一般设置为2min。也就是说客户端在进入TIME-WAIT状态，还要经过4min才能进入关闭状态 2. 为什么不直接进入CLOSED状态，而是要先进入TIME-WAIT如果在最后客户端向服务器端发送的TCP确认报文段没有到达客户端。那么超时后，客户端将重新发送TCP连接释放报文。但是此时如果已经进入CLOSE状态，并不会理会该报文。然后客户端一指发送TCP连接释放报文，一直处于LAST-ACK状态 3. 保活计时器TCP服务器进程没收到一次TCP客户进程的数据，就重新设置并启动保活计时器（2小时定时） 若保活计时器定时周期内未收到TCP客户进程发送的数据，则当保活计时器到时后，TCP进程就像TCP客户进程发送一个探测报文，以后每隔75秒发一次，十次后仍无TCP客户进程的回应，TCP服务器进程就认为TCP客户进程在主机发送故障，关闭这个连接 五、TCP可靠传输TCP基于以字节为单位的滑动窗口来实现可靠传输 可靠传输的实现 发送方的发送窗口并不总是和接收方的接收窗口一样大 对于不按序到达的数据，TCP通常将数据临时存放在接收窗口，等到字节流中缺少的字节收到后，再按序交付上层的应用进程 TCP要求接收方必须有累计确认和稍带确认机制。接收方不应该过分的推迟确认，否则会导致发送方不必要的超时重传。确认推迟的时间不应超过0.5s。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认。 TCP接收双方都有接收窗口和发送窗口 选择确认它允许TCP接收方有选择地确认失序报文段，而不是累积的确认最后一个正确接收地有序报文段。 当将该机制与选择重传（SR）机制结合起来使用时（即跳过重传那些已被接收方选择性确认过地报文段），Tcp看起来就像我们通常使用地SR协议，所以TCP地差错恢复机制也许最好分类为GBN协议与SR协议地混合体 六、TCP的流量控制所谓流量控制，就是让发送方的发送速率不要太快，要让接收方来得及接收 大概的过程如下描述： 假设一开始的rwnd为400字节 发送1~100号字节，还能发送300字节 发送101~200号字节，还能发送200字节 发送201~300号字节，但丢失了，还能发送100字节 接收方返回ACK=201，表示1~200号字节收到，rwnd=100+200=300号字节 发送301~400号字节，还能发送100号字节，因为之前的201~300号字节还没有确认 发送401~500号字节，不能发送新的数据了 超时重传201~300号字节 接收方返回ACK=301，还能发送100字节 发送501~600号字节，不能再发生新的数据了 接收方处理以前的数据，rwnd调整为0 在rwnd=0后，如果接收方处理完数据发送ACK给发送方时的报文丢失，那么就会陷入死锁，即发送方等待接收方的确认报文，接收方等待发送方发新的数据。 为了解决这个问题，TCP要求：当接收方的接收窗口为0时，发送方继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认，最终缓存清空，并在确认报文里将包含一个非0的rwnd值","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/TCP/","date":"12-03","excerpt":"","tags":[{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"运输层","slug":"运输层","permalink":"https://reiscarlet.github.io/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"}]},{"title":"IPv6","text":"[TOC] IPv6的优势 IPv6具有更大的地址空间 IPv6使用更小的路由表更大的地址空间 IPv6增加了增强的组播支持以及流支持 IPv6加入了对自动配置的支持 IPv6具有更高的安全性 IPv6的首部 Traffic class（通信量类）：占8位，用来区分不同IPv6数据报的类别或优先级 Flow Label（流标号）：占20位，所有属于同一个流的数据报都具有同样的流标号 流：就是互联网上从特定源点到特定终点的一系列数据报 Payload Length（有效载荷字段）：占16位，指明IPv6数据报除基本首部以外的字节数（所有拓展首部算在有效载荷之内） Next Header（拓展首部）：占8位 当IPv6没有拓展首部，Next Header的作用和IPv4的协议字段一样 当出现拓展首部，Next Header的值标识后面第一个拓展首部的类型 Hop Limit（跳数限制）：占8位，用来防止数据报在网络中无限期地存在，最大255跳，当Hop Limit为0，就要把这个数据报丢弃 拓展首部： IPv6把原来IPv4首部中选项地功能放在拓展首部中，并把拓展首部留给路径两端的源点和终点的主机来处理，路由器都不处理拓展首部（逐跳选项拓展首部除外），这样大大提高路由器的处理效率 IPv6的寻址IPv6地址由8个16进制字段构成，四个十六进制数一组，中间用“：”隔开。IPv6的基本表达方式是X:X:X:X:X:X:X:X，其中X是一个4位16进制整数（16位）。每一个数字包含4个比特 ，每个整数包含4个十六进制数字，每个地址包括8个整数，一共128位 IPv4和IPv6的区别 取消首部长度字段，因为IPv6的首部长度是固定的（40字节） 取消了服务类型字段，因为优先级和Flow Label(流标号)字段实现了服务类型字段的功能 取消了总长度字段，改用Payload length（有效载荷长度）字段 取消了标识、标志和片偏移字段，因为这些功能已包含在分片拓展首部 把TTL字段改为Hop limit（跳数限制）字段，但作用一样 取消了协议字段，改用Next Header（下一个首部）字段 取消了校验和字段 取消了选项字段，而用拓展首部来实现选项功能 IPv6不允许在中间路由器上进行分片与重新组装。这种操作只能在目的地执行。如果路由器接受的IPv6数据报过大而不能转发到出链路上，则路由器只需丢掉该数据报 IPv4到IPv6的过渡技术隧道技术IPv6数据报要进入IPv4网络时，把IPv6数据报封装成为IPv4数据报 当IPv4数据报离开IPv4网络时，再把数据部分（即原来的IPv6数据报）交给主机的IPv6协议栈 双协议栈使一部分主机或路由器装有双协议栈：一个IPv4和一个IPv6。记为IPv6/IPv4。 双协议栈同时域名系统DNS来查询目的主机是采用哪一种地址。若DNS返回IPv4就是IPv4，返回IPv6就是使用IPv6 用IPv4来发IPv6数据报，接收方在把IPv4还原成IPv6过程中，某些字段是无法恢复的 IPv6的写法","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/IPv6/","date":"12-03","excerpt":"","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"IPv4数据报","text":"网际协议版本4（英语：Internet Protocol version 4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANA IPv4位址完全用尽时，IPv6仍处在部署的初期 [TOC] 网络层的主要任务是实现网络互连，进而实现数据包在网络之间的传输 实现网络层的任务，需要解决以下主要问题： 网络层向运输层提供怎样的服务 网络层寻址问题 路由选择问题 IPV4数据报的首部形式 首部长度：占4比特，表示IP数据报首部的长度，该字段的取值以4字节为单位。 最小十进制取值为5，表示IP数据报首部只有20字节固定部分 最大十进制取值为15，表示IP数据报首部包含20字节固定部分和40字节的可变部分 可选字段：长度从1到40字节不等，用来支持排错，测量及安全措施 填充字段：确保首部长度为4字节的整数倍，使用全0进行填充 总长度：占16比特，表示IP数据报的总长度(首部+数据载荷)，最大取值65535字节 标识、标志、片偏移：共同用于IP数据报分片，当IP数据报长度超过MUT（首部+数据载荷）时将数据报分成几份 标志：占3比特，各比特含义如下： DF位：1表示不允许分片。0表示允许 MF位：1表示后面还有分片，0表示这是最后一个分片 保留位：必须为0 标识：占16比特，属于同个数据报的数据报分片应该具有相同的标识。IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将该值赋给标识字段 片偏移：占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有几个单位 生存时间TTL：8比特，路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器所耗费的时间，若不为0就转发，否则就丢弃 协议：占8比特，指明IPv4数据报部分是何种协议数据单元，常用的一些协议和相应的协议字段值如下 ICMP：1 IGMP：2 TCP：6 UDP：17 IPv6：41 OSPF：89 首部检验和：占16比特，用来检测首部在传输过程中是否出现差错，成为因特网检验和，IPv6中路由器不在计算首部校验和，从而更快的转发IP数据报。由于转发过程中标识等字段可变，所有首部校验和可变 IPv4地址概述因为32比特的IPv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用 将32比特的IPv4按每8位分为一组，写出每组的十进制数，在四个组间加上小数点 分类编址的IPv4地址： A类地址：8位网络号，24位主机号，网络号的最高位固定位0 B类地址：16位网络号，16位主机号，网络号的最高两位固定为10 C类地址：24位网络号，8位主机号，网络号的最高三位固定为110 D类地址：多播地址. 网络号的最高四位固定为1110 E类地址：保留为今后使用，网络号的最高四位固定为1111 只有A，C，B类地址可分配给主机或路由器的各接口 A类地址：最大网络号127作为本地唤回测试地址，不指派。最小网络号0，保留不指派。可指派的网络数量是$2^8 - 2 = 126$，则可配分的IP地址位$2^{24} - 2 = 16777214$(减去2是除去主机号全0的网络地址和全1的广播地址) B类地址：最小网络号也是第一个可指派的网络号128.0。最大网络号也是最后一个可指派网络号为191.255。可指派的网络号为$2^{(16-2)} = 16384$，每个网络可指派的IP地址为$2^{16} - 2 = 65534$ C类地址：最小网络号也是第一个可指派的网络号为192.0.0。最大网络号也是最后一个可指派网络号为223.255.255。可指派的网络号为$2^{(24-3)} = 2097152$。每个网络可指派的IP地址为$2^8 - 2 = 254$ 一些特殊的IP地址地址0.0.0.0是一个特殊的IPv4地址，只能作为源地址使用，表示“在本网络上的本主机”，封装有DHCP DIscovery报文的IP分组的源地址使用0.0.0.0，不能作为目的地址 受限广播地址：地址255.255.255.255是一个特殊的IPv4地址，只能作为目的地址使用，表示”在本网络上进行进行广播“，各路油器不转发 直接广播地址是主机号全为1的地址 127.X.X.X是环回地址，127.0.0.1 特指本机地址。 224.0.0.1 组播地址。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。 0.X.X.X。该系列地址仅用来标识主机 169.256.X.X。该系列地址是本地地址，是由操作系统分配，路由器不转发 划分子网的IPv4地址为新增网络申请新的网络号会带来以下弊端： 需要等待和花费更多费用 会增加其他路由器中路由表记录的数量 浪费原有网络中剩余的大量IP地址 所以我们可以从主机号部分借用一部分作为子网号 计算机如何知道分类地址中主机号有多少比特被用作子网号？ 32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号 子网掩码使用连续的比特1来对应网络号和子网号 子网掩码使用连续的比特0来对应主机号 将划分子网的IPv4地址与相对应的子网掩码进行逻辑与运算就可以得到IPv4地址所在的子网的网络地址 默认子网掩码：指在未划分子网的情况下使用子网掩码。A类地址未255.0.0.0，B类地址为255.255.0.0，C类地址为255.255.255.0 无分类编址的IPv4地址无分类域间路由选择CIDR。 CIDR消除了传统A，B ,C类地址以及划分子网的概念 CIDR可以更有效地分配IPv4的地址空间 CIDR使用斜线记法，在IPv4地址后面加上斜线”/“，在斜线后面写上网络前缀(网络号)所占的比特数量 CIDR实际上是将网络前缀都相同的连续IP地址组成一个”CIDR地址块“ 只要知道CIDR地址块的任何一个地址，就可以知道该地址块的全部细节： 地址块的最小地址 地址块的最大地址 地址块的地址数量 地址块聚合某类网络的数量 地址掩码 路由聚合（构造超网） 如何构造：找出路由表中目的地址的共同前缀，然后将找到的共同前缀的后一个字节写成2进制的形式，找出地址的共同前缀，然后计算共同前缀的比特位，并将共同前缀写成点分十进制的形式。在斜杠后写上刚才计算的比特位，得到聚合地址块 网络前缀越长，地址块越小，路由越具体 若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，因为这样的路由更具体 IPv4的应用规划定长子网掩码FLSM变长子网掩码VLSM在一个网络划分成n个子网时，计算出每个子网所需的主机地址，路由器接口地址，网络地址，广播地址，算出所有需要的主机号数目。得出每个子网所需主机号的位数，计算出每个子网对应的网络前缀位数。 分配过程中，每个子块的起点位置不能随意选取，只能选取块大小整数倍地址作为起点，一般先给大的子块分配 IP协议的主要特点：①IP协议是一种无连接、不可靠的分组传送服务的协议。 ②IP协议是点-点线路的网络层通信协议。 ③IP协议屏蔽了网络在数据链路层、物理层协议与实现技术上的差异。","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/IPv4首部格式/","date":"12-03","excerpt":"网际协议版本4（英语：Internet Protocol version 4，IPv4），又称互联网通信协议第四版，是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署的版本。IPv4是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6，直到2011年，IANA IPv4位址完全用尽时，IPv6仍处在部署的初期","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"ICMP","text":"作用：ICMP协议主要用来检测网络通信故障和实现链路追踪 IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。 为了更有效的转发IP数据报和提高交付成功的机会，在网络层使用了网络控制报文协议ICMP（Internet Control Message Protocol） 主机或路由器使用ICMP来发送差错报文和询问报文 ICMP报文被封装在IP数据报中发送 ICMP差错报告报文： 终点不可达 网络不可达 目的主机不可达 目的协议不可达 目的端口不可达 目的网络未知 目的主机未知 等等十三种 源点抑制：当路由器或主机由于拥塞而丢弃数据时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢 （生存）时间超过： 当路由器收到一个一个目的地址不是自己的IP数据报，会将生存时间TTL字段的值减1 若结果不为0，则将该数据报转发出去 若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文 当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超出报文 参数问题 当路由器或目的主机收到IP数据报后，根据首部中的检验字段和发现首部在传输过程中出现误码，就丢弃该数据报，并向源点发送参数问题报文 改变路由（重定向） 路由器把改变路由报文发送给主机，让主机知道下次应该将数据报发送给另外的路由器 以下情况不应发送差错报告报文： 对ICMP差错报告报文不再发送ICMP差错报告报文 对第一个分片的数据报片的所有后续数据报片都不发生ICMP差错报告报文 对具有多播地址的数据报都不发送ICMP差错报告报文 对具有特殊地址的数据报不发送ICMP差错报告报文 ICMP询问报文回送请求和问答ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问 收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文 这种询问报文用来测试目的站是否可达及了解其有关状态 时间戳请求和问答ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间 在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时间一共有多少秒 这种询问报文用来进行时钟同步和测量时间 ICMP应用举例分组网间探测PING（Packet InterNet Groper） 用来测试主机或路由器间的连通性 应用层直接使用网络层的ICMP（没有通过TCP或UDP） 使用ICMP回送请求和回答报文 跟踪路由traceroute 用来测试IP数据报从源主机到达目的主机主要经过哪些路由器 Windows版本 tracert命令 应用层直接使用网络层ICMP 使用ICMP回送请求和回答报文以及差错报告报文 Unix版本 traceroute命令 在运输层使用UDP协议 仅使用ICMP差错报告报文","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/ICMP/","date":"12-03","excerpt":"","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"ARP协议","text":"地址解析协议ARPARP（ Address Resolution Protocol，地址解析协议）是将 IP 地址解析为以太网 MAC 地址（或称物理地址）的协议。 源主机在自己的ARP高速缓存表中查找目的主机的IP地址所对应的MAC地址，若找到则可以封装MAC帧进行发送；若找不到，则发送ARP请求（封装在广播MAC帧中） 目的主机收到ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应（封装在单播MAC帧中），ARP响应中包括目的主机的IP地址和MAC地址 源主机收到ARP响应后，将目的主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后就可以封装之前想发送的MAC帧并发送给目的主机 注意： ARP协议只能在一段链路或者一个网络上使用，不能跨网络使用 ARP没有安全验证机制，存在ARP欺骗（攻击）问题","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/ARP协议/","date":"12-03","excerpt":"","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"PPP协议","text":"PPP(Point-to-Point Protocol, P2P)是目前使用最广泛的点对点数据链路层协议 PPP主要由以下三部分组成： 对各种协议的数据报的封装方法 链路控制协议LCP，用于建立、配置以及测试数据链路的连接 一套网络控制协议NCPs，对每一个协议支持不同的网络协议 PPP帧的格式 1字节 1字节 1字节 2节 不超过1500字节 2字节 1字节 标志 地址 控制 协议 数据载荷 FCS 标志 标志(Flag):PPP帧的定界符，取值为0x7E 地址(Address)：取值为0xFF,预留 控制(Control)：取值为0x03，预留 协议(Protocol)：指明帧的数据部分送交哪个协议处理： 取值0x0021：帧的数据部分为IP数据报 取值0xC021：帧的数据部分为LCP分组 取值0x8021：帧的数据部分为NCP分组 帧检测序列(FCS, Frame Check Sequence)：CRC计算出的校验码 PPP协议的工作状态： 注意：PAP认证过程是两次握手，而CHAP认证是3次握手，CHAP认证比PAP认证的安全性高","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/4.2 PPP协议/","date":"12-03","excerpt":"PPP(Point-to-Point Protocol, P2P)是目前使用最广泛的点对点数据链路层协议 PPP主要由以下三部分组成： 对各种协议的数据报的封装方法 链路控制协议LCP，用于建立、配置以及测试数据链路的连接 一套网络控制协议NCPs，对每一个协议支持不同的网络协议","tags":[{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"链路层","slug":"链路层","permalink":"https://reiscarlet.github.io/tags/%E9%93%BE%E8%B7%AF%E5%B1%82/"}]},{"title":"数据传输过程及以太网帧结构","text":"TCP/IP支持多种不同的数据链路层协议，这取决于网络所使用的硬件。基于不同硬件的网络使用不同形式的帧结构，以太网是当今应用最广泛的局域网技术。 [TOC] 以太网传输的数据帧有两种格式：Ethernet II帧结构、IEEE 802.3格式 两种协议的区别是： Ethernet II格式包含一个类型类型(Type)字段，标识以太帧处理完成之后将被发送到哪个上层协议及逆行处理 IEEE 802.3个格式中，同样的位置是长度(Length)字段 D.MAC S.MAC Type Data FCS D.Mac S.MAC Length LLC SNAP Data FCS 如何区分两种协议： Length/Type \\ge 1536(0x0600) \\quad Ethernet II \\\\ Length/Type \\le 1500(0x05DC) \\quad IEEE 802.3**目前以太网大多数数据帧使用的Ethernet II格式** 以太网在数据链路层通过MAC地址来唯一识别网络设备，并且实现局域网上网络设备之间的通信。 MAC地址也叫物理地址、硬件地址，大多数网卡厂商把MAC地址烧入网卡的ROM中，网络设备的MAC地址是全球唯一的 局域网帧的发送方式 单播：指从单一源端发送到单一的目的端。MAC地址中，第一字节第八个比特($b_0$)表示地址类型。对于主机MAC地址，这个比特固定位0 广播：指帧从单一的源端发送到共享以太网上的所有主机。广播帧的目的MAC地址为16进制的FF:FF:FF:FF:FF:FF，所有收到该广播帧的主机都要接受并处理这个帧 组播：组播转发可以理解为选择性的广播，组播MAC地址通过第一字节第八个比特($b_0$)区分，这个比特为1 以太网帧标识封装成帧：指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧 帧头和帧尾包含有重要的控制信息 帧头和帧尾的作用之一就是 以太网通过增加前同步码和帧开始定界符来标识一个帧的开始和结束 在传输媒体上实际传送的要比MAC帧还要多8个字节(由硬件生成)。这8个字节由两个字段构成，第一个字段是7个字节的前同步码(1和0交替码)。第二个字段是帧开始定界符，定义为10101011 以太网帧校验采用CRC校验 由于以太网规定了帧间间隔时间96比特的发送时间，因此MAC帧不需要帧结束定界符 透明传输：数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样. 面向字节的物理链路使用字节填充(字符填充)来实现透明传输 面向比特的物理链路使用比特填充的方法实现透明传输 在传输数据时，发送方数据链路层收到上层交付的协议数据单元，添加帧头和帧尾使之成为帧。但是如果数据中恰好包含这个特定数值，接收方将无法正确的接收数据。 面向字节：这个时候在发送帧之前，对帧的数据部分进行扫描。每出现一个帧定界符(flag)就在它前面添加一个转义字符(ESC), 面向比特：例如帧定界标志为01111110，在发送前对帧的数据部分进行扫描，每连续出现五个1就插入一个0，这样防止数据中出现帧定界标志 转义字符是一种特殊的控制字符，其长度一个字节，十进制值为27 为了提高帧的传输速率，应当使帧的数据部分长度尽可能的大些 考虑到差错控制多种因素，每一种数据链路层都规定了帧的数据部分长度上限，也就是最大传输单元MTU MAC地址，IP地址和ARP协议MAC地址是以太网的MAC子网所使用的地址，位于数据链路层 IP地址是TCP/IP体系结构的网络层所使用的地址 ARP协议属于TCP/IP体系结构的网络层。其作用是已知设备所分配的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址 MAC地址(物理地址、硬件地址·)一般被固化在网卡的电可擦可编程只读存储器EEPROM中 严格来说：MAC地址是对网络上各接口的唯一标识而不是网络上各设备的唯一标识 MAC地址包含两部分：前24比特是组织唯一标识符(OUI)，由IEEE统一分配给设备制造商；后24位序列号是厂商分配给每个产品的唯一数值，由各个厂商自行分配 标准表示法：每4个比特写成一个16进制的字符，两个字符一组共六组，组之间用‘-’或‘：’连接，例如XX-XX-XX-XX-XX-XX MAC地址中，第一字节的第7个比特取0表示全球管理，取1表示本地管理 IEEE802.3：MAC地址中，一个字节是$b_7b_6b_5b_4b_3b_2b_1b_0$，比特发送顺序是$b_0\\rightarrow b_7$。字节发送顺序是第一字节到第六字节 以太网V2的MAC帧结构（最长1518字节） 6字节 6字节 2字节 46~1500字节 4字节 目的地址 源地址 类型 数据载荷 FCS CRC 收发双方约好一个生成多项式$G(x)$ 发送方基于待发送的数据和生成多项式计算出差错检测码(冗余码)，将其添加到待传输数据的后面一起传输 接收方通过生成多项式来计算收到的数据是否产生误码 例如： \\begin{align} G(x) &= x^4 + x^2 + x + 1 \\\\ &= 1x^4 + 0x^3 + 1x^2 + 1x + 1 \\end{align}生成多项式各项系数构成的比特串为：10111 常用的生成多项式： CRC-16: $x^{16} + x^{15} + x^2 + 1$ CRC-CCITT: $x^{16} + x^{12} + x^{5} + 1$ CRC-32：$x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} + x^{11} + x^{10} + x^{8} + x^{7} + x^{5} + x^{4} + x^{2} + x + 1$ 计算差错检测码： 构造被除数，待发送信息后面添加生成多项式最高次数个0 构造除数：生成多项式的比特串 做”除法”,这里除法是将代被除数和除数进行异或 检查余数：余数的位数与多项式最高次数相同，位数不同则补0 例如：待发送信息为101001，生成多项式$G(x)=x^3+x^2+1$ 无法纠正错误，检错能力很好，计算复杂但易于用硬件实现，纠错码开销较大，计算机网络较少使用","path":"2021/12/03/计算机网络（学校）/第四章 IP网络基础/4.1数据传输过程及以太网帧结构/","date":"12-03","excerpt":"TCP/IP支持多种不同的数据链路层协议，这取决于网络所使用的硬件。基于不同硬件的网络使用不同形式的帧结构，以太网是当今应用最广泛的局域网技术。","tags":[{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"路由算法","text":"[toc] 1.路由算法的分类 静态路由算法 最短路径算法（Dijkstra）：从起点开始沿着最短路径延申连接网络的各个节点，构成一棵树——汇集树 动态路由算法步骤 测量 收集网络拓扑信息 主要收集自己附近的信息 更新 把收集的信息通知到别的路由器 收到别人的信息要更新自己的数据库 计算 根据收集的信息计算路由表-&gt;转发表 2.动态路由算法2.1 距离矢量算法——路由信息协议RIPDV（Distance Vector Routing）算法要点： 仅和相邻路由器交换信息； 路由交换的内容是自己的路由表； 周期性更新30s； RIP是内部网关协议IGP中最先得到广泛使用的协议之一，RIP要求自治系统AS的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录，称为距离向量D-V； 路由器到直连网络的距离：1； 路由器到非直连网络的距离：经过路由器数+1； 一条路径最多包含15个路由器，距离为16时表示目的不可达，所以RIP只适合小型网络； RIP认为好的路由就是所通过路由器数量最少的路由，当到达同一目的的不同路径所经过的路由一样时，进行等价负载均衡策略，即是将通信量均衡的分布到多条等价的路由上 RIP包含以下要点： 和谁交换信息——相邻路由器 交换什么信息——自己的路由表 何时交换信息——周期性交换 基本工作过程： 路由器刚开始工作时，只知道自己相连的直连网络的距离为1 每个路由器只和自己相邻的路由器周期性的更新路由信息，更新规则如下： 同一目的网络、下一跳，代表是最新消息，虽然距离可能更长，但也要更新 新的路由条目，添加 同一目的网络，不同下一跳，新的路由信息距离更短，更新 同一目的网络，不同下一跳，等价负载均衡 同一目的网络，不同下一跳，新的路由信息距离更长，不更新 经过若干次更新，每个路由器都知道本AS内各网络的最短距离和下一跳地址，称为收敛； RIP的“坏消息传播得慢”问题： 假设路由器R1和R2相连，R1的直连网络N1发生故障，R1检测到这个问题后，等到更新周期到了，就会发送一个（目的网络=N1，距离=16，下一跳=直连端口）的更新报文给R2，同时R2向R1发送（N1，2，R1）的更新报文，如果R2发送的报文更快到达，则R1会认为N1可以通过R2到达，R1就会向R2发送（N1，3，R2）的更新报文，R2收到后，就会更新报文（N1，4，R1），并且到下一个更新周期又发送给R1，一直重复R1-&gt;R2-&gt;R1的环路进行路由更新，直到发送（N1，16，R2）（N1，16，R1） 上述问题是距离向量的固有问题，解决办法如下： 限制最大路径距离15 进行“触发更新”，路由表发生更新立即发送更新报文，而不是周期性发送 路由器记录到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”） 2.2 链路状态路由算法——开放最短路径优先OSPF协议基本思想： 测量——发现邻居，测量与邻居间链路的开销 更新——把链路信息发送给网络中其他所有网络，并建立自己的链路状态数据库-&gt;重构拓扑结构图 计算——根据最短路径算法计算汇集树-&gt;生成路由表 距离矢量算法要点： 和所有的路由器交换信息 路由器交换的内容是自己邻居链路信息 事件触发更新 OSPF采用FPS算法计算路由，所以不会出现路由环路问题 使用OSPF的每个路由都会产生链路状态通告（Link State Advertisement, LSA），LSA包括 直连网络的链路状态信息 邻居路由器的链路状态信息 LSA被封装在链路状态更新分组LSU中，采用泛洪发送 使用OSPF的每个路由都有一个链路状态数据库LSDB，用于存储LSA 通过各路由器泛洪发送封装有自己的LSA的LSU分组，各路由器的LSDB最终达到一致 OSPF的五种分组类型 问候分组（HELLO）分组 数据库描述（Database Description）分组 链路状态请求（Link State Request）分组 链路状态更新（Link State Update）分组 链路状态确认（Link State Acknowledgment）分组 发现邻居：启动路由器后，路由器向每个点到点的线路发送一个携带自己网络地址HELLO分组，另一端收到后发送回一个应答通报自己的网络地址 HELLO分组封装在IP数据报中，发送到组播地址244.0.0.5 发送周期为10秒 40秒末未收到邻居路由器的HELLO分组，则认为邻居路由器不可达 | 源IP/路由器接口IP | 目的IP(244.0.0.5) | 协议号89 | OSPF首部 | OSPF分组载荷 || ————————- | ————————- | ———— | ———— | —————— | 测量线路开销：路由器发送一个ECHO分组要求对方立刻响应，测量一个来回的时间再除以2就能得到一个延迟估计值，这个值就是该线路的开销，如果要求更精确可以多测几遍然后取平均值 构造分组： 假设每个节点的分组表如下，用（邻居，代价）来表示当且节点到邻居节点需要的代价（延迟，带宽，距离等决定）： | A | B | C | D | E | F || —— | —— | —— | —— | —— | —— || 序号 | 序号 | 序号 | 序号 | 序号 | 序号 || 年龄 | 年龄 | 年龄 | 年龄 | 年龄 | 年龄 || B-4 | A-4 | B-2 | C-3 | A-5 | B-6 || E-5 | C-2 | D-3 | F-7 | C-1 | D-7 || | F-6 | E-1 | | F-8 | E-8 | 发布链路状态分组 以B为例子，相邻路由器为A、C、F，如果节点E的链路状态分组经过A和F到达B，节点B必须再将E的状态分组发送给C，这是因为A和F已经收到了，而B的相邻节点C没有收到，所以向C发送，以此类推，就能够实现向所有的路由器交换信息，最后节点B发送链路状态表如下： | 源 | 序号 | 年龄 | A | C | F | A | C | F | 数据 || —— | —— | —— | —— | —— | —— | —— | —— | —— | —— || A | 21 | 60 | 0 | 1 | 1 | 1 | 0 | 0 | || F | 21 | 60 | 1 | 1 | 0 | 0 | 0 | 1 | || E | 21 | 59 | 0 | 1 | 0 | 1 | 0 | 1 | || C | 20 | 60 | 1 | 0 | 1 | 0 | 1 | 0 | || D | 21 | 59 | 1 | 0 | 0 | 0 | 1 | 1 | | 其中前三个A、C、F是发送标志，后三个为ACK标志.每一行表示从源A发送的状态分组到达B后，B向哪个节点转发.例如第一行，表示A发送状态分组到达B后，B向C,F发送，所以C，F的发送标志置为1，又B收到A的分组后要向A发送ACK确认，所以A的ACK标志置为1 后续工作 收集链路信息建立链路状态数据库LSDB 重构拓扑图 根据拓扑图运行最短路径优先算法（SPF）计算汇集树 计算路由表 问题：如果一个网络中每个路由器都两两相邻，那么邻居关系数量为$\\Large\\frac{n(n-1)}{2}$，每次更新都要向n-1个路由器发送LSU分组 解决方法：在网络中的路由器选举一个指定路由器（designated router）和备用的指定路由器（backup designated router），所有的非指定路由器只与指定路由器建立邻居关系，所以非DR/BDR之间通过DR/BDR来交换信息，若DR出现问题，则使用BDR。 为了使OSPF能够用于规模更大的网络，OSPF把一个自治系统在划分为若干个更小的范围，叫做区域（Area） 每个区域都有一个32比特的区域标识符，主干区域标识符必须为0，其他区域的标识符不能为0且不能相同，每个区域最好不要规模太大，不要超过200个路由器。这样就把泛洪交换信息限制在一个小的区域 在一个区域内的路由器叫做区域间路由器IR 为了本区域可以和该自治系统的其他区域连通，每个区域都有一个区域边界路由器ABR，它的一个接口连接自身所在的区域，另一个接口连接到主干区域 主干区域内的路由器称为主干路由器BBR 其中主干路由器中还要有一个使得本自治系统和其他自治系统交换路由信息的自治系统边界路由器ASBR LSR的优点： 路由信息的一致性好，坏消息也一样传播的快 状态分组长度较短，传输所需要的网络带宽不大，适用于大型网络 LSR的缺点： 每个路由器都需要有较大的存储空间 计算量大，每次都必须计算最短路径 与距离矢量不同的是，距离矢量没有完整的拓扑图","path":"2021/12/03/计算机网络（学校）/第六章 路由协议/路由算法/","date":"12-03","excerpt":"","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"路由技术","slug":"路由技术","permalink":"https://reiscarlet.github.io/tags/%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/"}]},{"title":"路由协议概述","text":"[toc] 网络层提供的两种服务1. 面向连接的虚电路服务 其思想是可靠通信通过网络来保证，在网络层进行建立连接，建立完后通信双方沿着建立的虚电路发送分组，每个分组使用短的虚电路号标记（构成虚电路的每一段链路都有一个虚电路编号），属于同一条虚电路的分组均按照同一路由进行转发，因为整个过程虚电路只有一条，分组总是顺序到达终点。如果通信方式再使用可靠数据传输的网络协议，就能使方式的分组最终正确到达接收方。通信结束后需要释放建立的虚电路 2. 无连接的数据报服务 其思想是，可靠通信通过用户主机来保证。因为是无连接的，每个分组都有终点的完整地址，且每个分组可走不同的路由，分组也不一定个按序到达目的主机。在这个过程中很难去实现可靠数据传输，所以服务质量的保证很难去实现 路由选择协议概述静态路由选择： 由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等。这种配置方式简单、开销小但是不能及时适应网络状态的变化，一般只在小规模网络中 动态路由选择： 通过路由选择协议自动获取路由信息，能较好的适应网络状态的变化 特点： 自适应：动态路由选择，能较好的适应网络状态的变化 分布式：路由之间交换路由信息 分层次：将整个网络划分为许多较小的自治系统AS(Autonomous System) 自治系统： 自治系统内的路由选择为域内路由选择，自治系统间的路由选择为域间路由选择; 域间路由选择使用外部网关协议EGP这个类别的路由选择协议，而域内路由选择使用内部网关协议IGP这个类别的路由选择协议。 因为早期因特网没有路由器，使用的是网关，所以是只是路由选择的分类名称。现在具体为外部路由协议ERP；。自治系统间使用的外部网关协议为边界网关协议BGP。 一个自治系统内使用的内部网关协议与其他的自治系统无关，例如一个AS使用的内部网关协议为路由信息协议RIP，另一个AS可以是开放式最短路径优先OSPF协议； 常见的路由选择协议： 内部网关协议IGP： 路由信息协议RIP：基于距离向量，在因特网中最早使用 内部网关路由协议IGRP 增强型内部网关路由协议EIGRP 开放式最短路径优先OSPF：基于链路状态，在各种网络中广泛使用，集化成IS-IS是ISP骨干网上最常用的IGP协议 中间系统到中间系统IS-IS 外部网关协议EGP： 边界网关协议BGP 转发表是从路由表得出，路由表形式（目的网络，下一跳，路由条目类型） 路由选择标准 跳数：经过节点数量的多少，越小越好 地理距离：越小越好 带宽：传输速度，越大越好 负载：传输数据的量，越小越好 通信成本：越小越好 延迟：通信需要的时间，越小越好 静态路由配置直连路由：接口与目的网络直连，下一条不是路由器地址而是接口，（目的网络，接口，直连） 静态路由的配置：如果路由器R1向R2的所连的目的网络转发IP数据报，R1的下一跳应该转发给R2，但是R1的路由表中无法自动计算出该目的网络的路由条目，所以需要我们手动配置到达该目的网络的路由条目，也就是（目的网络，接口0的网络地址，静态），其中R1的接口1向R2的接口0进行转发，该路由条目类型是静态路由 默认路由：是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。对于路由器中相同下一跳的不同目的网络，用默认路由替代，目的网络为0.0.0.0/0，下一跳为转发到该目的网络所连接的路由器的接口的网络地址（0.0.0.0/0，接口0的网络地址，静态），其中R1的接口1向R2的接口0进行转发。举个例子：如果R1想要转发IP数据报给包含众多网络的因特网，人工一条条配静态路由是不可能的，我们可以直接配到这个因特网默认路由，对于到该因特网的数据报，直接转发给默认路由就是了 特定主机路由：路由器R1向R2中的某个特定主机的路由条目，R1接口1与R2接口0连接，形式为（特定主机的网络地址，接口0的网络地址，静态） 路由环路问题产生原因： 路由条目的下一条错误配置成其他路由的接口；例如有路由器R1-R2-R3连接着；R2向R1的某个目的地址转发数据报，在R2的路由表根据目的地址找出下一跳，但是R2的路由条目的错误配置成R3的接口，则R2向R3转发，R3在自己的路由表查到要转发到R1的目的地址，首先要将数据报转发给R2，这样数据报又回到了R2，R2又转发给R3，如此便形成了R2-&gt;R3-&gt;R2的环路 聚合了不存在的网络：假如路由器R1-R2相连，R1连着多个网络，R2的路由条目中目的地址对R1的网络进行路由聚合，如果R2的目的地址聚合了不存在的路由，如果R2要转发IP数据报给不存在的网络时，在R2的路由表中找到了聚合路由对应路由器R1的接口为下一跳，这样R2就会向R1转发给数据报，数据报到达R1后，R1进行查表转发，但是数据报的目的地址并不存在，所以R1会向默认路由转发数据报，R1的默认路由为R2，R2收到该数据报后，又转发给R1，所以形成了R2-&gt;R1-&gt;R2的环路 网络故障导致的路由环路问题：假如路由器R1-R2相连，如果R1某个接口所直连的网络出现故障而不可达，R1的路由表会自动删除到达该目的地址的路由条目，之后R2向R1的该故障网络转发数据报，数据报到达R1后，由于找不到该目的网络，所以向默认路由也就是R2转发数据报，R2收到数据报后，又会向R1转发，这样就形成了R2-&gt;R1-&gt;R2的环路 解决方法： 对于问题1，只需要在IP数据报设置TTL字段，每次进入路由器TTL-1，只要TTL=0，如果还没到达目的网络，丢弃 对于问题2，添加对于聚合了不存在的网络的黑洞路由，即下一条为null0，null0为路由器的虚拟接口，目的地址为被聚合的不存在的目的地址时，查表向null0转发数据报，也就是丢弃了该数据报，因为最长匹配原则，查表转发不会匹配到聚合路由的地址，而是匹配到黑洞路由的地址 对于问题3，在R1的路由表中，添加该故障网络的黑洞路由，R1收到该数据报后会匹配到黑洞路由，则该数据报会进入黑洞，即被丢弃，如果故障网络好了，配置的黑洞路由自动失效，路由器重新自动算出新的直连路由条目，如果又故障了，之前配置的黑洞路由又自动生效","path":"2021/12/03/计算机网络（学校）/第六章 路由协议/路由协议概述/","date":"12-03","excerpt":"","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"路由技术","slug":"路由技术","permalink":"https://reiscarlet.github.io/tags/%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/"}]},{"title":"外部网关协议","text":"边界网关协议BGP的基本工作原理相对于内部网关协议（例如RIP或者OSPF），外部网关协议（EGP）对于自治系统之间的路由选择，无法用代价作为度量来寻找最佳路由，因为不同的自治系统的代价的度量可能不同 同时自治系统间的路由选择还要考虑政治、经济、安全等因素 所以BGP只能尽力寻找一条能到达目的网络且比较好的路由（不能兜圈子），而非寻找一条最佳路由 在配置BGP时，每个自治系统管理员要选择至少一个路由器作为该自治系统的“BGP发言人” 不同的自治系统的BGP发言人要交换路由信息，首先要建立TCP连接，端口号为179 在此TCP连接上交换BGP报文建立BGP连接 利用BGP会话交换路由信息 使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站或对等站 BGP发言人除了运行BGP外，还必须运行自己所在的自治系统所使用的内部网关协议IGP，例如OSPF或RIP BGP发言人交换网络可达性信息，交换后各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由，也就是构造出树形结构，不存在环路问题的自治系统连通图 BGP-4的四种报文： OPEN报文：与相邻的BGP发言人建立关系 UPDATE报文：通告某一路由的信息，并且列出要撤销的多条路有 KEEPALIVE报文：用来周期性证实邻站的连通性 NOTICIFICATION报文：用来发送检测到的差错 在BGP协议刚运行时，BGP的邻站交换整个BGP路由表，以后只需要交换路由表中发生变化的部分，对节省网络带宽和减少路由器的处理开销都有好处 做题中的知识点： BGP属于距离矢量路由算法的增强协议，在原有路由信息的基础上加入路径信息，防止了路由环路的出现。","path":"2021/12/03/计算机网络（学校）/第六章 路由协议/外部网关协议/","date":"12-03","excerpt":"","tags":[{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"路由技术","slug":"路由技术","permalink":"https://reiscarlet.github.io/tags/%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/"}]},{"title":"高速以太网","text":"速率等于或超过100Mbps的以太网称为高速以太网 100BASE-T 以太网——快速以太网 100BASE-T是在双绞线上传送100Mb/s基带信号的星形拓扑以太网。 仍使用IEEE802.3的CSMA/CD协议。 它又称为快速以太网(Fast Ethernet)。 用户只需更换一张适配器，再配上一个100Mb/s的集线器，就可很方便地由10BASE-T以太网直接升级到100BASE- 而不需要改变网络的拓扑结构。 吉比特以太网——千兆以太网 吉比特以太网又称为千兆以太网。 吉比特以太网可用作现有网络的主干网，也可在高带宽(即高速率)的应用场合中用来连接工作站和服务器。 吉比特以太网的物理层使用以下两种成熟的技术：(1)来自现有的以太网。(2)ANSI制定的光纤通道FC(Fibre Channel)。 吉比特以太网的标准IEEE802.3z有以下几个特点：(1)允许在1Gb/s下全双工和半双工两种工作方式。(2)使用IEEE802.3协议规定的帧格式。(3)在半双工方式下使用CSMA/CD协议，而在全双工方式下不需要使用CSMA/CD协议。(4)与10BASE-T和100BASE-T技术向后兼容。 10吉比特以太网——万兆以太网 10吉比特以太网又称为万兆以太网。 10GE并非将吉比特以太网的速率简单地提高到10倍。 由于10GE的出现，以太网的工作范围已经从局域网扩大到城域网和广域网，从而实现了端到端的以太网传输。这种工作方式的好处是：(1)以太网是一种经过实践证明的成熟技术，无论是因特网服务提供者ISP还是端用户都很愿意使用以太网。(2)以太网的互操作性也很好，不同厂商生产的以太网都能可靠地进行互操作。(3)在广域网中使用以太网时，其价格大约只有SONET的五分之一和ATM的十分之一，以太网还能够适应多种的传输媒体，如铜缆、双绞线和各种光缆，这就使具有不同传输媒体的用户在通信时不需重新布线。(4)端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧格式的转换，这就简化了操作和管理。 10吉比特以太网的物理层使用以下两种新开发的技术：(1)局域网物理层 LAN PHY。(2)可选的广域网物理层 WAN PHY。 10吉比特以太网的特点：(1)10GE的帧格式与10Mb/s、100Mb/s和1Gb/s以太网的帧格式完全相同。(2)由于传输速率高，10GE不再使用铜线而只使用光纤作为传输媒体。(3)10GE只工作在全双工方式，因此不存在争用问题，也不使用CSMA/CD协议。 注：以太网从10Mb/s到10Gb/s的演进证明了以太网是：(1)可扩展的(从10Mb/s到10Gb/s)。(2)灵活的(多种媒体、全/半双工、共享/交换)。(3)易于安装。(4)稳健性好。 使用高速以太网进行宽带接入高速以太网接入的一个重要特点：是它可以提供双向的宽带通信，并且可以根据用户对带宽的需求灵活地进行带宽的升级。高速以太网接入可以采用多种方式，其中一种方式——光纤到大楼FTTB。(1)每个大楼的楼口都安装一个100Mb/s的以太网交换机(对通信量不大的楼房也可以使用10Mb/s的以太网交换机)。(2)然后根据情况在每一楼层安装一个10Mb/s或100Mb/s的以太网交换机。(3)各大楼的以太网交换机通过光纤汇接到光结点汇接点。(4)若干个光结点汇接点再通过吉比特以太网汇接到一个高速汇接点(称为GigaPoP)。(5)然后通过城域网连接到因特网的主干网。","path":"2021/12/03/计算机网络（学校）/第五章 交换技术/高速以太网/","date":"12-03","excerpt":"","tags":[{"name":"交换技术","slug":"交换技术","permalink":"https://reiscarlet.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/"}]},{"title":"虚拟局域网","text":"虚拟局域网VLAN概述由于一个或多个以太网交换机互连起来的交换式以太网同属于一个广播域，随着交换式以太网规模的扩大，广播域相应扩大，巨大的广播域带来一下弊端： 广播风暴 难以维护和管理 潜在的安全问题 广播风暴会浪费网络资源和各个主机的CPU资源 分割局域网：由于路由器默认情况不对广播数据包进行转发，因此路由器可以隔离广播域，但是路由器的成本较高。为了解决这个问题，我们引入VLAN技术来分割广播域。 虚拟局域网VLAN(Virtual Local Area Network)是一种将局域网内的设备划分成**与物理位置无关**的逻辑组的技术，这些逻辑组**具有某些共同的需求**","path":"2021/12/03/计算机网络（学校）/第五章 交换技术/虚拟局域网/","date":"12-03","excerpt":"","tags":[{"name":"交换技术","slug":"交换技术","permalink":"https://reiscarlet.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/"}]},{"title":"交换机工作原理和生成树协议","text":"[toc] 以太网交换机自学习和转发帧的流程以太网交换机，也称为交换式集线器，**是简化（典型）的网桥**，一般用于互连相同类型的LAN（例如：以太网/以太网的互连）。交换机和网桥的不同在于：交换机端口数较多；交换机的数据传输效率较高。 透明网桥：自学习算法（逆向学习法）的网桥 以太网交换机在数据链路层，包括物理层 以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧 以太网交换机是一种即插即用设备，刚上电启动时其内部的帧的交换表是空的。随着网络中个主机间的通信，以太网交换机通过自学习算法自动逐渐建立起帧交换表 由于MAC地址与接口的对应关系不是永久性的，所以每条记录都有自己的有效时间，到期自动删除 交换机对于一个port N上incoming frame， 学习其source MAC X， 生成MAC Address Table，如下： MAC X &lt;———&gt; Port N 这样它就会生成MAC地址 和 Port 的映射表，如果收到一个Frame ，就会查询Frame的 Destination MAC 与MAC Address Table 进行匹配，匹配到了就从对应的Port 发送出去。 如果没有匹配到，就认为是 unknown Unicast 或 broadcast，没有办法只好把它从所有Port( 除了接收到Frame的接口）发送出去 以太网交换机的生成树协议STP单点故障：在网络中，任意一个节点产生故障，将导致整个网络无法通讯 为了提高以太网的可靠性，我们通过添加冗余链路来提高以太网的可靠性，但是，冗余链路带来另一个问题——形成网络环路 但是网络环路带来以下问题： 广播风暴：大量消耗网络资源，使得网络无法正常转发其他数据帧 主机收到重复的广播帧：大量消耗主机的资源 交换机的帧交换表震荡（漂移） 为此，以太网交换机使用生成树协议STP（Spanning Tree Protocol），增加冗余链路的网络可靠性的同时又避免网络环路带来的各种问题： 不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的链路，其逻辑拓朴结构必须是树形 最终生成树的树型拓扑结构要确保联通整个网络 当首次连接交换机或网络物理拓扑结构发生变化时，交换都将进行生成树的重新计算 **STP协议通过在逻辑上将特定的端口进行阻塞，从而解决网络中存在的二层环路问题同时使网络在二层物理链路中存在冗余** STP的生成 每个广播域中选举一个根桥（Root） 每个非根桥选举一个根端口（Root Port） 每一段链路选举一个指定端口（Designated Port） 非指定端口会被堵塞（Blocking） 选举根桥：具有最低桥ID的交换机就是根桥，BID相同时，选择MAC地址小的作为根桥 选举根端口：选举了根桥后，其他的交换机就成为了非根桥。根桥上的接口都是指定端口，会转发数据包。每台非根桥要选举一条到根桥的根路径。根端口通过计算到根桥的最短路径选举得到。 链路带宽 新标准 10Mbps 100 100Mbps 19 1Gbps 4 10Gbps 2 &gt;10Gbps 1 选举指定端口：一般而言，交换机端口是否配置为指定端口由 BID 决定。当两个非根端口的交换机端口连接到同一个 LAN 网段时，会发生竞争端口角色的情况。这两台交换机会交换 BPDU 帧，以确定哪个交换机端口是指定端口，哪一个是非指定端口","path":"2021/12/03/计算机网络（学校）/第五章 交换技术/生成树协议/","date":"12-03","excerpt":"","tags":[{"name":"交换技术","slug":"交换技术","permalink":"https://reiscarlet.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/"}]},{"title":"经典局域网的交换技术","text":"[TOC] 媒体接入的基本概念媒体接入控制MAC（Medium Access Control）：协调多个发送核接收站点对一个共享传输媒体的占用 媒体接入控制： 静态划分信道： 预先固定好信道，非常不灵活，对于突发性传输信道利用率很低，通常在无线网络的物理层使用，而不是在数据链路层中使用，分为频分多址，时分多址，码分多址 动态接入信道 受控接入：已被淘汰 集中控制 分散控制 随机接入： 所有站点通过竞争随机的在信道发送数据，如果恰巧有两个或更多的站点在同一时刻发送数据，则信号在共享媒体上就要发生碰撞，即发生了冲突使得这些站点的发送都失败。因此，这类协议要解决关键问题：如何避免冲突，以及冲突后如何尽快的恢复通信 现在，点对点链路和链路层交换式局域网在有线领域已完全取代了共享式局域网，但由于无线通信的广播天性，无线局域网仍然使用共享媒体技术 CSMA/CD协议载波监听多址接入/碰撞检测 CSMA/CD（Carrier Sense Multiple Access/Collision Detection） 多址接入MA：多个站连接在一条总线，竞争使用总线 载波监听CS：每个站在发送帧之前先检测一下总线上是否有其他站点在发送帧，即“先听后说”；若检测到总线空闲96比特时间，则发送这个帧 碰撞检测CD：每一个正在发送帧在站边发送边检测碰撞，即是“边说边听”；一旦发现总线上发生碰撞立刻停止发送，一段时间后再次发送 CSMA/CD协议不适用于无线网络。对于无线网络，可以使用CSMA/CA协议 CSMA/CD协议——争用期 主机最多经过2α就检测到碰撞（A-&gt;D-&gt;A），所以以太网的端到端往返传播时延2α为争用期或碰撞窗口 显然，在以太网中发生帧的主机越多，端到端的传播时延越大，发生碰撞的概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长 经过争用期还没有检测到碰撞，才能肯定这次发送不会发生碰撞 CSMA/CD协议——最小帧长产生问题：如果主机A发送了一个很小的帧，发送完后主机A就不再检测碰撞了。然后主机C发送帧，由于主机A发送的帧很小，所以主机C因为判断总线空闲96比特时间，所以发送帧。但是总线实际并不空闲。这样子就必然发生碰撞。这样接收方就会收到A发送的并遭遇碰撞的帧，所以接收方会丢弃有差错的帧。但是A不知道发送的帧遭遇了碰撞，所以不会重发该帧。 所以以太网的帧长不能太短 以太网规定最小帧长为64字节，即是512比特（512比特即为争用期）；如果发送的帧没有64比特，就必须加入填充字节。 如果争用期内检测到碰撞，就立即中止发送，此时发送的数据一定小于64字节。因为凡是小于64字节的帧都是由于碰撞而异常终止的无效帧 **最小帧长=争用期*数据传输速率** CSMA/CD协议——最大帧长产生问题：如果主机A给D发送一个很长的帧。那么发送过程中有可能该帧长期占据了总线的资源，导致其他主机检测到总线空闲没有96比特时间而长时间无法发送帧。同时接收方可能因为帧过于长导致缓冲区满了而溢出。 所以以太网V2的MAC帧最大长度设为1518字节，其中46~1500字节为数据载荷部分 插入VLAN标记后的802.1Q帧设最大长度为1522字节。其中数据载荷部分42~1500字节 CSMA/CD协议——截断二进制指数退避算法退避时间=基本退避时间*随机数r 其中基本退避时间为争用期，随机数r从离10散的整数集合{0，1，….，$（2^k-1）$}中随机选出一个数.k=Min{重传次数，10} 若连续多次发生碰撞，就表明有较多的主机参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大，因为减少发生碰撞的概率，有利于整个系统的稳定 当重传次数16仍不成功，表明同时打算发送帧的主机太多，以至于连续发生碰撞，则丢弃该帧，并向高层报告 CSMA/CD协议——信道利用率理想情况下： 各个主机发送帧不会发生碰撞 总线一旦空闲就有某个主机立即发送帧 发送一帧占用总线的时间为$T_0 + α$，而帧本身的发送时间为$T_0$，α是传送时延 极限的信道利用率$\\large S_{max}=\\LARGE\\frac{T_0}{T_0+\\alpha} = \\frac{1}{1+\\frac{\\alpha}{T_0}}$。 设β=α/T_0。则β应该尽量小，以提高信道利用率； 以太网端到端的距离应该收到限制，减少α的值；以太网帧的长度应该尽量长些； CSMA/CD协议——帧发送过程 CSMA/CD协议——帧接收流程","path":"2021/12/03/计算机网络（学校）/第五章 交换技术/媒体接入的基本概念/","date":"12-03","excerpt":"","tags":[{"name":"交换技术","slug":"交换技术","permalink":"https://reiscarlet.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/"}]},{"title":"网络协议与网络体系结构","text":"网络体系结构重要概念 协议：为计算机网络中的数据交换而建立的规则、标准或约定的集合。 分层：分层次（Layer）是人们处理复杂问题的基本方法。当人们遇到一个复杂问题的时候，通常习惯将其分解为若干个小问题，再一一进行处理。 接口：接口：相邻两层之间的边界，在接口处规定了低层向上层提供的服务以及服务所使用的形式规范语句(服务原语)。 服务：某一层提供的功能，并能通过接口提供给其相邻上层。 网络体系结构：对计算机网络的各层功能精确定义及其各层遵守协议的集合。 协议栈：网络各层协议按层次顺序排列而成的协议序列。 OSI失败的原因 OSI的专家们缺乏实际经验，他们在完成OSI标准时缺乏商业动力 OSI的协议实现起来过于复杂，而且运行效率很低 OSI标准的制定周期太长，因而使得OSI标准生产的设备无法及时进入市场 OSI的层次划分不太合理，有些功能在多个层次中重复出现 网络协议三要素 语法：数据与控制信息的结构或格式（怎么做） 语义：需要发出何种控制信息，完成何种动作以及做出何种响应（做什么） 时序：即事件实现顺序的详细说明（做的顺序） 分层的好处 各层之间是独立的：某一层不需要知道其他层如何实现，仅仅需要知道通过层间接口所提供的服务 灵活性好：只要层间接口关系不变，则其他层均不受影响 结构上可分割开：各层都可以采用最合适的技术实现 易于实现和维护：使得实现和调试一个庞大又复杂的系统变得易于处理，因为整个系统被分解为若干个相对独立的子系统了 能促进标准化工作：因为每一层的功能及其所提供的服务都已经有了精确的说明 通常各层所要完成的功能主要有以下一些 差错控制：使相应层次对等方的通信更加可靠 流量控制：发送端的发送速率必须使接收端来得及接收 分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端复原 复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用 连接建立和释放：交换数据前先建立一条逻辑连接，数据传输结束后释放连接 分层也有缺点，有些功能会在不同的层次中重复出现，因而产生额外的开销 体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件","path":"2021/12/03/计算机网络（学校）/第二章 网络体系架构与网络协议/网络协议与网络体系结构/","date":"12-03","excerpt":"","tags":[{"name":"计算机网络概述","slug":"计算机网络概述","permalink":"https://reiscarlet.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"}]},{"title":"参考模型","text":"模型的基本原则 应该在需要一个不同抽象体的地方创建一层 每一层都应该执行一个明确定义的功能 每一层功能的选择应该向定义国际标准化协议的目的看齐 层与层边界的选择应该使跨越接口的信息流最小 层数要足够多，保证不同的功能不会混杂在同一层中，同时层数不能太多，以免体系结构过于庞大 物理层物理层关注在一条通路上传输原始比特 在物理层上所传数据的单位是比特 物理层实现的主要功能在于提出了物理层设备的机械特性、电气特性、功能特点 数据链路层数据链路层的主要任务：将一个原始的传输设施转变成一个没有漏检传输错误的线路 在两个相邻结点之间传输数据时，数据链路层将网络层交下来的IP数据报组装成帧(frame)，在两个相邻结点间的链路上传送帧，每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等…） 数据链路层不仅要检错，还要纠错 网络层网络层负责为分组交换网上的不同主机提供通信服务网络层将运输层产生的报文段或数据报封装成分组(packet)或包进行传送网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机 运输层负责向两台主机中进程间的通信提供通用的数据传输服务由于一台主机可以同时运行多个进程，因而运输层有复用和分用的功能 运输层主要使用以下协议 传输控制协议TCP——提供面向连接，可靠的数据传输服务，其数据传输的单位是报文段 用户数据报协议UDP——提供无连接，尽最大努力的数据传输服务，其数据传输单位是数据报 应用层是体系结构的最高层任务是通过应用进程间的交互来完成特定网络应用应用层协议定义的是应用进程间通信和交互的规则我们把应用层交互的数据单元称为报文(message)","path":"2021/12/03/计算机网络（学校）/第二章 网络体系架构与网络协议/参考模型/","date":"12-03","excerpt":"","tags":[{"name":"计算机网络概述","slug":"计算机网络概述","permalink":"https://reiscarlet.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"}]},{"title":"网络设备","text":"1.集线器 目的：解决终端主机的物理连接问题，将在其内部所有的网络设备联通 不过滤任何数据，也不知道数据发送到什么地方 终端集中点，通过集线器形成星型拓扑 物理层设备 对信号整型放大 共享一个信道，性能比较差 会将信息传到除自己以外的所有主机，哪怕只想和其中的一个通信，造成浪费带宽 因为不能读取IP地址，所以不能在外部网络（例如互联网）交换数据 2.交换器 数据链路层设备，能够解析数据帧结构 使用MAC地址，能够根据MAC地址进行主机的定位寻址，所以信息只会发送到目的主机减少带宽的浪费和集线器不同 独享信道，所以交换机的性能远远超过集线器 不能读取IP地址 3.路由器 实现网络连接进行数据交换 网络层设备 可以读取IP地址，所以可以将数据包发送到外部网络 输入输出端口安装了三种协议软件，分别是物理层，数据链路层，网络层 总之，集线器和交换机构建网络，路由器将网络与网络连接起来4.防火墙 防火墙是一个系统，用来防止未经授权的网络传输侵入私有的网络系统，是由过滤传输的数据来达到这个效果 目的：要在公共网络和私人的网络间建立一道流量管控机制 防火墙由网络管理员管理和制定规则 防火墙可以针对网域名，协议，软件，IP地址，端口和关键词来制定规则 防火墙有多种形式，一种是主机式防火墙，一种是软件式防火墙，网络式防火墙 5.无线接入点（WiFi） 延申网络覆盖范围 移动设备接入点","path":"2021/12/03/计算机网络（学校）/第三章 网络传输、设备与企业网架构/网络设备/","date":"12-03","excerpt":"","tags":[{"name":"网络传输、设备与企业网架构","slug":"网络传输、设备与企业网架构","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E3%80%81%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BD%91%E6%9E%B6%E6%9E%84/"},{"name":"物理层","slug":"物理层","permalink":"https://reiscarlet.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"}]},{"title":"编码与调制","text":"基带信号分为 数字基带信号 模拟基带信号 信道可分为： 数字信道 模拟信道 对于数字信号​ 在不改变信号性质的前提下，仅对数字基带信号的波形进行变换，成为编码，编码后的信号仍为数字信号 把数字信号的频率范围搬移到较高的频段，并转化为模拟信号，称为调制 ​ 对于模拟信号同上 码元在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形 传输媒体和信道不能划等号一个传输媒体只有一条发送信道和一条接收信道，而信道却可以通过复用技术拥有多条发送信道和接收信道 常用编码 不归零编码 需要额外一条传输线来传输时钟信号，使发送方和接收方同步 由于存在同步问题，计算机网络的数据传输不采用这种编码 归零编码 每个码元传输结束后信号都要归零，所以接收方只要信号归零后进行采样即可，不需要单独的时钟信号 归零编码相当于把时钟信号用归零方式编码在数据内，这称为自同步信号 归零编码中大部分的数据带宽用来传输归零而浪费掉了，编码效率低 曼切斯特编码 码元中间时刻的跳变即表示时钟，又表示数据 传统以太网用的这种编码 差分曼切斯特编码 跳变仅表示时钟 码元开始处电平是否发生变化表示数据 10BaseT以太网使用的曼切斯特编码基本调制方法 使用基本调制方法，一个码元只能包含一个比特信息，如何使用一个码元包含更多的比特呢？​ 因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个 ​ 通常情况下，相位和振幅可以结合来一起调制，称为正交振幅调制QAM","path":"2021/12/03/计算机网络（学校）/第三章 网络传输、设备与企业网架构/编码与调制/","date":"12-03","excerpt":"","tags":[{"name":"网络传输、设备与企业网架构","slug":"网络传输、设备与企业网架构","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E3%80%81%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BD%91%E6%9E%B6%E6%9E%84/"},{"name":"物理层","slug":"物理层","permalink":"https://reiscarlet.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"}]},{"title":"物理层","text":"2.物理层概述2.1物理层的基本概念用于物理层的协议被称为物理层规程 物理层的主要任务描述为确定与传输媒体的接口有关的一些特性： 机械特性 电气特性 功能特性 过程特性 数据在计算机内部多采用并行传输方式，但数据在通信线路上的传输方式一般都是串行传输 2.2 数据通信基础知识2.2.1数据通信系统的模型 一个数据通信系统可划分为三大部分： 源系统（发送端、发送方），一般包含以下两部分： 源点：源点设备产生要传输的数据 发送器：通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输 传输系统（传输网络） 目的系统（接收端、接收方），一般包含以下两部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息 终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出 一些术语： ​ 通信的目的是传送消息，数据是运送消息的实体，根据RFC 4949的定义，数据是使用特定方式表示的信息，信号是数据的电气或电磁表现。 根据信号中代表消息的参数的取值不同，信号可分为两大类： 模拟信号，或连续信号 数字信号，或离散信号 2.2.2 有关信道的几个基本概念信道和电路并不同，信道一般都是用来表示向某一个方向传送消息的媒体。因此通信电路往往包含一个发送信道和一条接受信道 从通信的双方交互的方式来看，可以有以下三种基本方式： 单向通信：只能有一个方向的通信而没有反方向的交互，无线电广播或有线电广播以及电视广播就属于这种类型 双向交替通信：通信双方都可以发送消息，但不能双方同时发送 双向同时通信：通信双方可以同时发送和接收信息 来自信源的信号常称为基带信号 基带信号往往包含较多的低频成分，甚至直流成分，而许多信道并不能传输这种低频分量或直流分量，为了解决这一问题，就必须对基带信号进行调制 调制可分为两大类 基带调制：仅仅对基带信号的波形进行变换，变换后仍是基带信号，也称这一过程为编码 使用载波进行调制：把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，经过载波调制后的信号称为带通信号，而使用载波的调制称为带通调制 常用编码方式 不归零制：正电平为1，负电平为0 归零制：正脉冲为1，负脉冲为0 曼切斯特编码：位周期中心的向上跳代表0，位周期中心的向下跳代表1。也可以反过来定义 差分曼切斯特编码：在每一位的中心始终有跳变，位开始边界的跳变代表0，位开始边界没有跳变代表1 基本的带通调制方法 调幅（AM）：载波的振幅随基带数字信号的变化而变化 调频（FM）：载波的频率岁基带数字信号而变化 调相（PM）：载波的初始相位岁基带数字信号而变化 为了达到更高的信号传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。例如**正交振幅调制** 2.2.3 信道的极限容量数字通信的优点：虽然信号在信道上传输会不可避免的失真，但在接收端只要从失真的波形识别出原来的信号，那么这种失真对通信质量就没有影响 限制**码元**在信道上的传输速率大的因素有以下两个： 1. 信道能够通过的频率范围：具体的信道所能通过的频率范围是有限的，信号中的高频分量往往不能通过信道 2. 信噪比：噪声存在于所有的电子设备和通信信道中，噪声会使接收端对码元的判决（识别）产生错误 需要知道的是：在任何信道中，码元传输的速率是由上限的，传输速率超过此上限，就会出现严重的**码间串扰问题**，使得接收端对码元的识别成为不可能 所谓的信噪比就是信号的平均功率和噪声的平均功率之比，记为$\\frac{S}{N}$,并用分贝（dB）作为度量单位 信噪比（dB）= $10log_{10}(\\frac{S}{N})(dB)$ 信道的极限信息由香农公式传输速率$C = W log_{2}(1+\\frac{S}{N})(bit/s)$ 其中W为信道带宽，S为信道所传信号的平均功率，N为信道的高斯噪声功率 **香农公式指出，信道的带宽或信道中的信噪比越大，信道的极限传输速率就越高**","path":"2021/12/03/计算机网络（学校）/第三章 网络传输、设备与企业网架构/物理层/","date":"12-03","excerpt":"","tags":[{"name":"网络传输、设备与企业网架构","slug":"网络传输、设备与企业网架构","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E3%80%81%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BD%91%E6%9E%B6%E6%9E%84/"},{"name":"物理层","slug":"物理层","permalink":"https://reiscarlet.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"}]},{"title":"信道极限容量","text":"奈氏准则在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的 理想低通信道的最高码元传输速率：2W Baud = 2W 码元/秒 理想带通信道的最高码元传输速率：W Baud = W 码元/秒 W：信道带宽（单位为Hz） Baud：波特，即码元/秒 实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的上限数值 码元传输速率又称为波特率，调制速度，波形速率或符号速率，它与比特率有一定关系 当1个码元携带1比特信息量时，波特率(码元/秒)与比特率(比特/秒)在数值上相等 当1个码元携带n比特信息量时，波特率转换为比特率时，数值要乘于n 香农公式公式：$c = W log_2(1 + \\frac{S}{N})$ 其中W为信道带宽，S为信道所传信号的平均功率，N为信道的高斯噪声功率 $\\frac{S}{N}$是信噪比（dB）= $10log_{10}(\\frac{S}{N})(dB)$ 在实际信道上能够达到的信息传输速率要比要公式的极限传输速率低不少。这是因为在实际信道中，信号还要受到其他一些损伤，如各种脉冲干扰、信号在传输中的衰减和失真等，这些因素未被考虑到香农公式 相关习题","path":"2021/12/03/计算机网络（学校）/第三章 网络传输、设备与企业网架构/信道极限容量/","date":"12-03","excerpt":"","tags":[{"name":"网络传输、设备与企业网架构","slug":"网络传输、设备与企业网架构","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E3%80%81%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BD%91%E6%9E%B6%E6%9E%84/"},{"name":"物理层","slug":"物理层","permalink":"https://reiscarlet.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"}]},{"title":"传输媒介与传输方式","text":"传输媒体可分为两大类： 导引型传输媒体 双绞线:成本低 三类双绞线 五类双绞线 同轴电缆：有线电视线 光纤：带宽大 优点: 带宽高 衰减小 安全 维护 缺点： 需要光电转化 非导引型传输媒体 传输方式 串行传输 发送端和接收端只需要一条传输线路即可 并行传输 成本高 发送速度使串行传输的n倍 发送端和接收端间需要n条传输线路 同步传输 数据块以稳定的比特流传输 字节之间没有间隔（同步） 由于不同设备的时钟频率存在差异，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号的判别错位，实现收发双方时钟同步的方法主要有两种 外同步：在收发双方之间添加一条单独的时钟信号线 内同步：发送端将时钟同步信号编码到发送数据中一起传输 异步传输 以字节为独立的传输单位 字节之间的时间间隔不是固定的（异步） 接收端仅在每个字节的起始处对字节内的比特实现同步，为此要在每个字节的前后加上起始位和结束位 字节中的每个比特仍要同步 单向通信 双向交替通信 双向同时通信 **数据在传输线路上的传输是串行传输，计算机内部常采用并行传输**","path":"2021/12/03/计算机网络（学校）/第三章 网络传输、设备与企业网架构/传输方式/","date":"12-03","excerpt":"","tags":[{"name":"网络传输、设备与企业网架构","slug":"网络传输、设备与企业网架构","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E3%80%81%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BD%91%E6%9E%B6%E6%9E%84/"},{"name":"物理层","slug":"物理层","permalink":"https://reiscarlet.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"}]},{"title":"","text":"习题总结 利用模拟通信信道传输数字信号的方法称为( ) 解析：频带传输 基带传输：在数据通信中，由计算机或终端等数字设备直接发出的信号是二进制数字信号 频带传输：远距离通信信道多为模拟信道，基带信号与频带信号的转换是由调制解调技术完成的 在网络中，把语音与计算机产生的数字、文字、图形与图像同时传输，必须先把语音信号数字化，下列可以把语音信号数字化的技术是( ) 解析：脉冲编码调制 PCM 以下属于数据链路层的设备是（） 解析： 交换机 网桥 目前常用的网络连接器主要有、、____和网关。 解析： 中继器 网桥 路由器 网关 局域网中常用的拓扑结构主要有星型、____、总线型三种。 解析：环型 企业网络能被外部客户访问的区域是 解析：DMZ区域 波特率等于( )。 A每秒传输的比特 B每秒可能发生的信号变化次数 C每秒传输的周期数 D每秒传输的字节数 解析：每秒可能发生的信号变化次数 典型企业网络包含（）区域 解析： 数据中心 边缘区域 DMZ 【单选题】 下面的说法哪一种是正确的（）。 A、路由器适合大规模异构网络互连 B、MAC地址适合大规模网络寻址 C、三层交换机适合大规模异构网络互连 D、BGP适合自治系统内的路由选择 解析：A 下面的说法哪一个是正确的？ A、路由器具有路由选择功能，交换机没有路由选择功能 B、三层交换机具有路由选择功能，二层交换机没有路由选择功能 C、三层交换机适合异构网络，二层交换机不适合异构网络 D、路由器适合异构网络，交换机不适合异构网络 解析：D","path":"2021/12/03/计算机网络（学校）/第三章 网络传输、设备与企业网架构/习题/","date":"12-03","excerpt":"","tags":[]},{"title":"应用层概述","text":"应用的的相关协议： 万维网 域名系统DNS 动态主机配置协议DHCP 电子邮件 文件传送协议FTP P2P文件共享 多媒体网络应用","path":"2021/12/03/计算机网络（学校）/第七章 应用层/应用层概述/","date":"12-03","excerpt":"","tags":[{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"Telnet","text":"Telnet协议Telnet协议是TCP/IP协议族的一员，它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用Telnet程序，用它连接到服务器。终端使用者可以在Telnet程序中输入命令，这些命令会在服务器上运行，要开始一个Telnet会话，必须输入用户名和密码来登录服务器。使用端口为53 Telnet服务属于C/S模型的服务，这使得能实现基于Telnet协议的远程登陆。远程登陆是指用户输入Telnet命令，使自己的计算机暂时称为远程主机的一个仿真终端的过程。仿真终端负责把用户输入的每个字符传给主机，再将主机的每个信息回显在屏幕上。 工作原理Telnet提供了三种基本服务 Telnet定义一个网络虚拟终端，为远程系统提供一个标准接口。客户机程序不需要详细了解远程系统，他们只需要构造使用标准接口的程序 Telnet包括允许客户机和服务器协商选项的机制，它还提供了一组标准选项 Telnet对称处理连接的两端，即Telnet不强迫客户机从键盘输入，也不强迫客户机在屏幕显示输出 为了解决异构计算机系统互联中存在的问题，Telnet协议引入网络虚拟终端(Network Virtual Termianl, NVT)的概念，它提供一种专门的键盘定义，用来屏蔽不同计算机对键盘输入的差异性，同时定义客户与远程服务器之间的交互过程，该协议又称“网络虚拟终端协议”，“终端仿真协议”，“远程终端协议” Telnet使用NVT来定义如何从客户机将控制功能传输到服务器。当用户从本地输入普通字符时，NVT将按原始含义传送，当用户输入快捷键时，NVT将把它转换为特殊的ASCII字符在网络时传输，并到达远程机器后转化为相应的控制命令 讲正常的ASCII字符集与控制命令区分的原因： 意味着Telnet具有更大的灵活性：它可在客户机与服务器间传输所有可能的ASCII字符以及所有控制功能 使客户机可以无二义性的指定命令，而不会产生控制功能与普通字符的混乱 Telnet有个缺点：效率不高。因为数据被用户从本地键盘输入后通过操作系统—-&gt;客户机程序—-返回—-&gt;操作系统—-网络传输—-&gt;远程机器—-&gt;服务器程序—-&gt;操作系统的伪端口入口点—-&gt;用户正在运行的应用程序。这个过程的开销巨大，但由于用户键入的速率不高，所以总体可接受 如果本地用户运行了远程机器的一个无休止循环的错误命令或程序，且此命令或程序已经停止输入，则操作系统的缓存区可能因此被占满—-&gt;则远程服务器也无法将数据写入伪终端—-&gt;导致停止从TCP连接读取数据—-&gt;TCP连接的缓冲区最终被占满—-&gt;数据流流入此链接—-&gt;本地用户失去对远程机器的控制 为此，Telnet协议必须使用外带信号以便于强制服务器读取一个控制命令。 TCP用紧急数据机制实现外带信号，Telnet再添加一个被称为数据标记的保留八位组，再让TCP发送已设置紧急数据比特的报文段通知服务器便可以。作为对紧急信令的回应，服务器将读取并抛弃所有数据，直到找到一个数据标记后返回正常的处理过程 由于Telnet两端的机器和操作系统的异构性，Telnet不可能也不应该严格规定每个Telnet连接的详细配置，否则将大大影响Telnet的适应异构性。 因此Telnet采用选项协商机制来解决这一问题 Telnet工作过程前提：必须知道远程主机的IP地址或域名；必须知道登录标识与口令 Telnet远程服务分为四个过程： 本地与远程主机建立TCP连接 将本地终端输入的用户名和口令以及输入的任何命令或字符以NVT格式传送到远程主机。该过程实际上是本地主机向远程主机发送一个IP数据报 将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果 本地终端对远程主机进行一个TCP撤销连接 Telnet命令格式 IAC 命令码 选项码 IAC：命令解释符，每条指令的前缀都是它，固定值255 命令码：一系列定义…… 对于任何给定的选项，连接的任何一方都可以发送下面4种请求的任意一个 WILL：发送方本身被激活选项 DO：发送方想叫接收端激活选项 WON‘T：发送方本身想禁止选项 DON’T：发送方想让接收端去禁止选项 所以协商有六种情况： | 发送者 | 接收者 | 说明 || ——— | ——— | ———————————————————————— || WILL | DO | 发送方想激活某选项，接收方接受该选项请求 || WILL | DON’T | 发送方想激活某选项，接收方拒绝该请求 || DO | WILL | 发送方希望接收者激活某选项，接收方接受该选项请求 || DO | DON’T | 发送方希望接收者激活某选项，接收方拒绝该请求 || WON’T | DON’T | 发送方希望使某选项无效，接收者必须接受该请求 || DON’T | DON’T | 发送方希望对方使某选项无效，接收者必须接受该请求 | 选项码：要激活或禁止的选项 E-mail，FTP和Web服务都是建立在Telnet NVT的基础上的","path":"2021/12/03/计算机网络（学校）/第七章 应用层/Telnet/","date":"12-03","excerpt":"","tags":[{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"P2P与C/S","text":"网络应用程序运行在网络边缘的端系统上，彼此通过通信完成某项任务。 开发一种新的网络应用首先要考虑的就是网络应用程序在各种端系统上的组织方式和它们之间的关系 目前流行的有： 客户/服务器(Client/Server,C/S)方式 对等(Peer-to-Peer,P2P)方式 C/S方式 客户和服务器是指通信过程中所涉及的两个应用进程 客户/服务器描述的是进程之间服务和被服务的关系 客户是服务请求方，服务器是服务提供方 服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号，运行服务器的主机也具有固定的IP地址 基于C/S的应用服务通常都是服务集中型，即应用服务集中在网络中比客户计算机少得多的服务计算机上 由于客户计算机远比服务器计算机多得多，所以常常出现服务器计算机跟不上众多客户计算机的请求的清空 为此，C/S应用中常用计算机集群构建一个强大的虚拟服务器 P2P方式 在P2P方式中，没有固定的服务请求者和服务提供者 P2P的应用是服务分散型的，因为服务不是集中在少数的服务器计算机中 P2P的最突出的特性之一就是它的可拓展性，因为系统每增加一个对等方，不仅增加服务的请求者，同时增加了服务的提供者，系统性能不会因规模增大而降低 P2P具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽","path":"2021/12/03/计算机网络（学校）/第七章 应用层/P2P/","date":"12-03","excerpt":"","tags":[{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"文件传输协议FTP","text":"将某台计算机中的文件通过网络传输到可能相距很远的另一台计算机中就是文件传输 文件传输协议FTP提供交互式访问，允许客户指明文件类型和格式，并允许文件具有存取权限 FTP屏蔽了各计算机系统的细节，所以适合在异构网络中任意计算机之间传送文件 FTP服务器既可以是一台高性能的服务器计算机，也可以是一台普通的个人计算机 如果要访问所创建的FTP服务器，用的是ftp而不是http协议 FTP工作原理 FTP客户随机选择一个临时端口号与FTP服务器上监听的端口号21建立TCP连接，传送FTP的控制命令，这条TCP连接是FTP客户与服务器之间的命令通道 当有数据要传输时，FTP客户通过命令通道告知FTP服务器来与自己另一个临时端口号建立TCP连接，而FTP服务器则使用自己的熟知端口号20与其建立TCP连接，这条连接是TCP客户与服务器之间的数据通道，反之则为被动连接，不同的是，被动链接时是FTP客户与服务器都是随机选择一个临时端口号进行连接；由于建立数据通道时是FTP服务器主动连接FTP客户，故称为主动连接 控制连接在整个会话期间一直保持打开，而数据连接只有在文件传输时才建立，传输结束就关闭","path":"2021/12/03/计算机网络（学校）/第七章 应用层/FTP/","date":"12-03","excerpt":"","tags":[{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"域名系统DNS","text":"DNS(Domain Name System)：主机的一种标识方式是用它的主机名(hostname)，主机也可以使用所谓的IP地址进行标识，人们喜欢便于记忆的主机名标识方法，而路由器喜欢定长的，有着层次结构的IP地址，所以我们需要一种能进行主机名到IP地址转换的目录服务，以满足不同的需求，这就是DNS，DNS协议运行在UDP上，使用53号端口 早在1983，因特网就开始使用层次结构的命名树作为主机的名字（即域名），并使用分布式的域名系统DNS；DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高；由于DNS是分布式系统，所以单个计算机出现故障也不会妨碍整个系统的正常运行 域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名 每一级域名由不超过63个字符的数字和英文组成，不区分大小写 级别低的在左边，级别高的在右边 完整域名不超过255个字符 各级域名由上一级域名管理机构管理，最高级的顶级域名由因特网与数字地址分配机构ICANN管理 顶级域名分为以下三类 国家顶级域名nTLD 通用顶级域名gTLD： 最常见的有七个：com(公司企业)，net(网络服务机构)，org(非营利性组织)，int(国际组织)，edu(美国教育结构)，gov(美国政府部门)，mil(美国军事部门) 反向域arpa：用于反向域名解析，即IP-&gt;域名 在国家顶级域名下注册的二级域名由该国家自行确定 我国将二级域名分为 类别域名 共七个：ac(科研机构)，com(工、商、金融等企业)，edu(教育机构)，gov(政府部门)，net(提供网络服务的机构)，mil(军事机构)，org(非营利性组织) 行政区域名: 共34个省34个 域名服务器分为以下四种 根域名服务器：共13个，每个服务器实际上是由许多分布世界各地的计算机构成的服务器集群，当本地域名服务器发送查询请求时，路由器就把报文转发到离这个DNS客户最近的一个根域名服务器。根域名服务器通常不对域名进行解析，而是返回该域名所属顶级域名服务器的IP地址。 顶级域名服务器：管理该顶级域名的所有二级域名。收到DNS查询请求时就给出相应的回答，这个回答可能是下一级权限域名服务器的IP地址 权限域名服务器：负责管理某个区的域名，每个主机的域名都必须在某个域名权限服务器注册登记。权限域名服务器还知道其下级域名服务器的地址。权限域名服务器知道其管辖的域名与IP地址的映射关系 本地域名服务器：当一个主机发送DNS请求报文，这个报文首先被送到该主机的本地域名服务器。本地域名服务器转发到上述的域名服务器的等级结构中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。 域名解析的过程 由于递归查询对于被查询的域名服务器负担太大，通常从主机到本地域名服务器之间的查询是递归查询，而其余查询是迭代查询 为了提高DNS的查询效率，并减轻根域名服务器的负担和减少因特网上的DNS查询报文数量，在域名服务器中广泛的使用了高速缓存用来存放最近查询过的域名以及何处获得域名映射信息的记录 由于域名和IP地址的映射关系不是不变的，域名服务器应该为每项内容设计计时器并删除超出合理时间的项 用户主机中也使用了高速缓存存放最近使用的域名，这样只有在缓存中查找不到域名时才想域名服务器查询。同理也需要保持主机的高速缓存中内容的正确性","path":"2021/12/03/计算机网络（学校）/第七章 应用层/DNS/","date":"12-03","excerpt":"","tags":[{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"动态主机配置DHCP","text":"[toc] DHCP的作用一个主机如果要访问Internet，首先我们要手动配置IP地址信息，DNS服务器等网络相关配置，但如果主机的数目特别多时，显然全部手动配置并不现实，所以我们有动态主机配置DHCP DHCP可以为局域网各个主机配置以下信息 IP地址 子网掩码 默认网关 DNS服务器 这样主机开机启动DHCP后就可以自动获取网络配置信息 DHCP的工作过程假设有多个DHCP服务器和一个DHCP客户，DHCP客户服务使用的UDP端口68号，DHCP服务器使用的UDP端口号是67，封装有DHCP报文的UDP用户数据报在网络层被封装成IP数据报，然后再根据所使用的网络接口，封装成相应的数据链路帧进行发送 DHCP客户启动时，会广播发送DHCPDISCOVER报文，封装该报文的IP数据报的 源IP地址为0.0.0.0，因为此时DHCP客户还没有分配到IP地址 目的IP地址为255.255.255.255，因为DHCP客户不知道网络中有几个DHCP服务器 对于网络中的其他主机收到该IP数据报，其应用层没有监听该UDP用户数据报目的端口67的进程，所以收到后只会丢弃 DHCPDISCOVER封装有事务ID和DHCP客户端的MAC地址 DHCP服务器收到DHCPDISCOVER报文后，根据封装的MAC地址查找自己的数据库，看是否有针对该MAC地址的配置信息，如果有用这些配置信息构建DHCPOFFER报文，否则用默认配置信息来构建 源IP地址为DHCP服务器 目的IP地址为255.255.255.255，因为DHCP客户此时还没有配置IP地址 对于网络中的其他主机，由于应用层没有监听UDP用户数据报的目的端口68的进程，收到后只会丢弃 DHCP客户根据DHCPOFFER报文中的事务ID是否和自己发送的DHCPDISCOVER报文的事务ID相同，以此来判断是不是自己所请求的报文 DHCPOFFER封装有事务ID，配置信息有：IP地址、子网掩码、地址租期、默认网关，DNS服务器等 DHCP服务器从自己的IP地址池挑选IP地址时，会先用ARP来确保IP地址未被网络中的其他主机占用 DHCP客户会收到来自同一网络的所有DHCP服务器提供的DHCPOFFER报文，客户从中选择一个，一般来说选最先到的那一个，并向所选择的DHCP服务器发送DHCPREQUEST报文 源IP地址为0.0.0.0，因为DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器，它需要征得该服务器的同意，之后才能正式使用该DHCP服务器租用的IP地址 目的地址为255.255.255.255，这样就不用向网络中的每个DHCP服务器单播DHCPREQUEST报文来告知它们是否请求它们作为DHCP服务器 DHCPREQUEST报文封装有事务ID，DHCP客户端的MAC地址，接受的租约中的IP地址，提供此租约的DHCP服务器的IP地址等 DHCP服务器收到DHCPREQUEST报文后，如果服务器接受该请求，向DHCP客户发送DHCPACK报文 源IP地址为DHCP服务器的IP地址 目的IP地址为255.255.255.255 DHCP客户收到DHCPACK报文后，主机使用ARP检测该IP地址是否被网络的其他主机占用，若被占用就重新发送DHCPDISCOVER报文，否则就可以使用该IP地址和网络中的其他主机通信了 DHCP客户在使用租用的IP地址经过0.5倍的租用期时，向DHCP服务器发送DHCPREQUEST报文来请求更新租用期，发送的IP数据中 源IP地址为当前的IP地址 目的IP地址为DHCP服务器IP地址 DHCP服务器收到DHCPREQUEST报文后，如果同一租约续租，发送一个DHCPACK报文给DHCP客户，这样客户就得到新的租期，否则发送DHCPNACK报文拒绝请求，此时DHCP客户必须停止使用之前租用的IP地址 如果DHCP服务器没有反应，在经过租期的0.875倍后，DHCP客户会再发送一个DHCPREQUEST报文请求租期续约 如果租用期到期后，DHCP客户必须停止使用之前租用的IP地址，并重新发生DHCPDISCOVER报文来申请新的地址 DHCP客户可以随时提前终止DHCP服务器所提供的租用期，只需要向DHCP服务器发生DHCPRELEASE报文即可，IP数据报中 目的IP地址为255.255.255.255 源IP地址为0.0.0.0 DHCP中继代理如果DHCP客户与所需要的DHCP服务器经由一个路由器相连，这时候DHCP客户能够自动获取到IP地址吗？ 答案是不行，因为路由器不会转发一个广播报文，而是丢弃，所以我们需要给该路由器配置DHCP服务器的IP地址并使之称为DHCP中继代理，这样路由器收到广播的DHCPDISCOVER报文后，单播转发给DHCP服务器，DHCP客户使用DHCP中继代理的主要原因是我们并不想在每个网络都设置一个DHCP服务器","path":"2021/12/03/计算机网络（学校）/第七章 应用层/DHCP/","date":"12-03","excerpt":"","tags":[{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"非线性最小二乘问题","text":"[toc] 前置知识最小二乘问题定义：$min\\ f(x)=\\large\\frac{1}{2}\\normalsize\\sum_{i=1}^mr_i^2(x)=\\large\\frac{1}{2}\\normalsize r(x)^Tr(x)=\\large{\\frac{1}{2}}\\normalsize{||r(x)||_2^2}$ 其中，$r(x)$称为剩余函数，如果$r(x)$有一个不是线性函数，那么就是非线性最小二乘问题 f(x)的导数设$J(x)$是$r(x)$的Jacobi矩阵,$J(x)=[\\nabla{r_1(x),…,\\nabla{r_m(x)}}]^T=\\nabla{r(x)}$ 梯度 \\begin{aligned} &\\because \\frac{\\partial (r(x)^Tr(x))}{\\partial{r(x)}}=2r(x)\\\\ &\\therefore \\frac{\\partial r(x)^Tr(x)}{\\partial{x}}=\\frac{\\partial{r(x)^Tr(x)}}{\\partial{r(x)}}\\frac{\\partial{r(x)}}{\\partial{x}}\\\\ &\\therefore \\frac{\\partial{r(x)^Tr(x)}}{\\partial x}=2r(x)\\nabla{r(x)}\\\\ &\\therefore \\nabla{f(x)}=\\nabla{(\\frac{1}{2}r(x)^Tr(x))}=r(x)\\nabla{r(x)}\\\\ &\\therefore \\nabla{f(x)}=r(x)J(x) \\end{aligned}Hesse矩阵 \\begin{aligned} \\nabla^2f(x)&=\\nabla(r(x)\\nabla{r(x)})\\\\ &=\\nabla{r(x)}^T\\nabla{r(x)}+r(x)\\nabla^2r(x)\\\\ &=J(x)^TJ(x)+S(x) \\end{aligned}其中$S(x)=r(x)\\nabla^2r(x)$ Gauss-Newton方法对$f(x)$,进行一阶Taylor展开，得到$f(x+\\Delta{x})\\approx f(x)+f’(x)\\Delta{x}=f(x)+J(x)\\Delta{x}$ 代入$\\Delta x=arg\\ min\\ \\frac{1}{2}||f(x+\\Delta x)||^2_2$,得到 \\begin{aligned} F(\\Delta x)&=\\frac{1}{2}||f(x+\\Delta{x})||^2_2\\\\ &=\\frac{1}{2}(f(x)^Tf(x)+(J(x)\\Delta{x})^T(J(x)\\Delta{x})+2f(x)^TJ(x)\\Delta{x})\\\\ \\end{aligned}对$\\Delta x$求导，得到 \\begin{aligned} \\frac{\\partial{F(\\Delta{x})}}{\\partial{\\Delta{x}}}=f(x)^TJ(x)+2J(x)^TJ(x)\\Delta{x} \\end{aligned}其中，如果令$g(x)=J(x)\\Delta{x}$,则$(J(x)\\Delta{x})^T(J(x)\\Delta{x})=g(x)^Tg(x)$,则 \\begin{aligned} \\frac{\\partial (J(x)\\Delta{x})^T(J(x)\\Delta{x})}{\\partial{\\Delta x}}&=\\frac{\\partial{g(x)^Tg(x)}}{\\partial{g(x)}}\\frac{\\partial{g(x)}}{\\partial{x}}\\\\ &=2g(x)J(x)\\\\ &=2J(x)^TJ(x)\\Delta{x} \\end{aligned}所以令$f(x)^TJ(x)+2J(x)^TJ(x)\\Delta{x}=0$ 得到$J(x)^TJ(x)\\Delta{x}=-f(x)^TJ(x)$ 因为$f(x_{k+1})-f(x_k)=G_{k+1}(x_{k+1}-x_k)$,即牛顿方程$G_{k}d_k=g_k$ 又$G(x)=J(x)^TJ(x)+S(x)$,所以$(J_k^TJ_k+S_k)d_k=-J_k^Tf_k$ 忽略$S_k$后，即是$J(x)^TJ(x)\\Delta{x}=-f(x)^TJ(x)$ 所以Guass-Newton方程就是Newton方程中忽略$S_k$得到的 LM方法对$f(x)$,进行一阶Taylor展开，得到$f(x+\\Delta{x})\\approx f(x)+f’(x)\\Delta{x}=f(x)+J(x)\\Delta{x}$ 所以$\\Delta{x^*}=arg\\ min_{\\Delta{x}}(\\frac{1}{2}||f(x)+J(x)\\Delta{x}||^2_2)$ 加入阻尼项,$\\Delta{x^*}=arg\\ min_{\\Delta{x}}(\\frac{1}{2}||f(x)+J(x)\\Delta{x}||^2_2+\\frac{1}{2}\\mu{\\Delta{x}^T\\Delta{x}})=M(\\Delta{x})$ 求导，得到 \\begin{aligned} \\frac{\\mathrm{d}M(\\Delta{x})}{\\mathrm{d}\\Delta{x}}&=\\frac{1}{2}\\frac{\\mathrm{d}}{\\mathrm{d}\\Delta{x}}(f(x)^Tf(x)+(J(x)\\Delta{x})^T(J(x)\\Delta{x})+2f(x)^TJ(x)\\Delta{x}+\\mu{\\Delta{x}^T\\Delta{x}})\\\\ &=f(x)^TJ(x)+J(x)^TJ(x)\\Delta{x}+\\mu\\Delta{x}\\\\ &=f(x)^TJ(x)+(J(x)^TJ(x)+\\mu{I})\\Delta{x} \\end{aligned}令其等于0，也就是$(J(x)^TJ(x)+\\mu{I})\\Delta{x}=-f(x)^TJ(x)$ 所以$\\Delta{x^*}=-(J(x)^TJ(x)+\\mu{I})^{-1}f(x)^TJ(x)$","path":"2021/12/03/数值最优化/非线性最小二乘问题/","date":"12-03","excerpt":"","tags":[{"name":"数学证明","slug":"数学证明","permalink":"https://reiscarlet.github.io/tags/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"}]},{"title":"负梯度方法和Newton型方法","text":"[toc] 最速下降法最速下降法即下降方向是梯度的负方向，步长由精确线搜索得到 一般步骤如下： 给出$x_0,k:=0$ 若终止条件满足，迭代停止 计算$d_k=-g_k$ 精确线搜索得到$\\alpha_k$ $x_{k+1}:=x_k-\\alpha_kg_k,k:=k+1$,转步2 对目的函数$min_x\\ f(x)=\\frac{1}{2}x^TAx+b^Tx+c$ 一阶导数$g_k= \\nabla{f(x_k)} =Ax+b$ 又更新公式为$x_{k+1}=x_k-\\alpha_kg_k$ 求$\\alpha$，由$g_{k+1}^Tg_k=0$,带入 \\begin{aligned} g_{k+1}&=Ax_{k+1}+b\\\\ &=A(x_k-\\alpha_kg_k)+b\\\\ &=Ax_k+b-A\\alpha_k\\nabla{f(x_k)}\\\\ &=g_k-A\\alpha_kg_k \\end{aligned}所以 \\begin{aligned} g_{k+1}^Tg_k&=(g_k-A\\alpha_kg_k)^Tg_k\\\\ &=(g_k^T-\\alpha_kg_k^TA^T)g_k\\\\ &=0 \\end{aligned}所以$\\alpha_k=\\Large\\frac{g_k^Tg_k}{g_k^TAg_k}$ 所以$x_{k+1}=x_k-\\Large{\\frac{g_k^Tg_k}{g_k^TAg_k}}\\normalsize g_k$ Newton 方法对于要优化的目标函数$f(x)$，当前迭代点为$x_k$，则$f(x)$在$x_k$处的Taylor展开式为 f(x_k+d)\\approx f(x_k)+\\nabla{f(x)}^Td+\\frac{1}{2}d^T\\nabla^2f(x)d当$x_k$固定时，$d$取多少使得$f(x_k+d)$最小？当$f(x_k+d)$最小，则$f(x_k+d)$对$d$的偏导为0 \\begin{aligned} &\\frac{\\partial}{\\partial{d}}f(x_k+d) = \\nabla{f(x)} + \\nabla^2f(x)d = 0\\\\ &\\therefore d = -\\nabla^2f(x_k)^{-1}\\nabla{f(x_k)} \\\\ &\\therefore x_{k+1} = x_k + d = x_k - \\nabla^2f(x_k)^{-1}\\nabla{f(x_k)}\\\\ &\\therefore x_{k+1} = x_k - G_k^{-1}g_k \\end{aligned}拟Newton方法Newton方法的缺点：每步迭代都需要计算Hesse矩阵，为此需要计算二阶偏导；若该方法产生的迭代点不能充分接近极小点，$G_k$的正定性不能保证 Newton方法的优点：具有二阶收敛速度 所以我们构造一种不需要计算二阶偏导，又具有较快的收敛速度，我们采用了拟Newton方法 对目标函数$f(x)$在$x_{k+1}$处进行Taylor展开，得到 \\begin{aligned} f(x)&\\approx f(x_{k+1}) + \\nabla{f(x_{k+1})}(x-x_{k+1}) + \\nabla^2f(x_{k+1})(x-x_{k+1}) \\\\ &= f(x_{k+1}) + \\nabla^2f(x_{k+1})(x-x_{k+1})\\\\ \\end{aligned}令$x=x_k$，有$f(x_k)=f(x_{k+1})+G_{k+1}(x_k-x_{k+1})$ 令$f(x_{k+1})-f(x_k)=y_k,x_{k+1}-x_k=s_k$，则有 G_{k+1}s_k=y_k因为$B_{k+1}$是$G_{k+1}$的近似矩阵，所以同样的也有: B_{k+1}s_k=y_k若记$H_{k+1}=B_{k+1}^{-1}$,则 H_{k+1}y_k=s_k拟牛顿方法是确定迭代方向d的最优化方法 每次迭代中，我们还要修正$H_{k+1}$，即是$H_{k+1}=H_k+\\Delta{H_k}$中确定$\\Delta H_k$ 拟Newton法修正公式对称秩1公式（Symmetric Rank 1，SR1）令$B_{k+1}=arg\\ min_{B^T=B}||B-B_k||$ 考虑更新$B_{k+1}=B_k + \\frac{1}{a}vv^T$，代入$B_{k+1}s_k=y_k$，得到 \\begin{aligned} (B_k+\\frac{1}{a}vv^T)s_k&=y_k\\\\ \\frac{v^Ts_k}{a}v&=y_k-B_ks_k \\end{aligned}所以$v$与$y_k-B_ks_k$同向，令$v=\\tilde{a}(y_k-B_ks_k)$，则 B_{k+1}=B_k+\\frac{\\tilde a^2}{a}(y_k-B_ks_k)(y_k-B_ks_k)^T设$b=\\Large\\frac{\\tilde a^2}{a}$，两边同乘于$s_k$，得 \\begin{aligned} B_{k+1}s_k&=B_ks_k+b(y_k-B_ks_k)(y_k-B_ks_k)^Ts_k \\\\ y_k&=B_ks_k+b(y_k-B_ks_k)(y_k-B_ks_k)^Ts_k\\\\ y_k-B_ks_k&=b(y_k-B_ks_k)(y_k-B_ks_k)^Ts_k\\\\ 1&=b(y_k-B_ks_k)^Ts_k\\\\ \\therefore b&=\\frac{1}{(y_k-B_ks_k)^Ts_k} \\end{aligned}由$b=\\Large\\frac{\\tilde a^2}{a}$，令$\\tilde a=1$，得到$a=(y_k-B_ks_k)^Ts_k$ 将$\\tilde a=1$代入$v=\\tilde{a}(y_k-B_ks_k)$,得到$v=y_k-B_ks_k$ 将$v=y_k-B_ks_k,a=(y_k-B_ks_k)^Ts_k$代入$B_{k+1}=B_k+\\Large\\frac{1}{a}\\normalsize vv^T$，得到 \\begin{aligned} B_{k+1}&=B_k+\\frac{1}{(y-B_ks_k)^Ts_k}(y_k-B_ks_k)(y_k-B_ks_k)^T\\\\ B_{k+1}&=B_k+\\frac{(y_k-B_ks_k)(y_k-B_ks_k)^T}{(y-B_ks_k)^Ts_k} \\end{aligned}DFP公式对秩2公式$H_{k+1}=H_k + \\alpha u_ku_k^T+ \\beta v_kv_k^T$ 令$E_k = \\alpha u_ku_k^T+ \\beta v_kv_k^T$则$H_{k+1}=H_k+E_k$,代入拟牛顿方程$H_{k+1}y_k=s_k$,得到 (H_k+E_k)y_k=s_k其中$v_k^Ty_k=\\begin{bmatrix}v_1\\...\\\\v_n\\end{bmatrix}^T\\begin{bmatrix}y_1\\...\\\\y_n\\end{bmatrix}=v_1y_1+…+v_ny_n$是一个常数,$u_k^Ty_k$同理 即是 \\begin{aligned} (H_k+\\alpha u_ku_k^T+ \\beta v_kv_k^T)y_k&=s_k\\\\ H_ky_k+\\alpha{u_ku_k^Ty_k}+\\beta{v_kv_k^Ty_k}&=s_k\\\\ \\alpha(u_k^Ty_k)u_k+\\beta(v_k^Ty_k)v_k&=s_k-H_ky_k\\\\ \\end{aligned}假设$u_k=rH_ky_k,v_k=\\theta s_k$,则 \\begin{aligned} E_k&=\\alpha{rH_ky_k}(rH_ky_k)^T+\\beta{\\theta{s_k}(\\theta{s_k})^T}\\\\ &=\\alpha r^2H_ky_ky_k^TH_k+\\beta \\theta^2s_ks_k^T \\end{aligned}代入$\\alpha(u_k^Ty_k)u_k+\\beta(v_k^Ty_k)v_k=s_k-H_ky_k$,得 \\begin{aligned} &\\alpha[(rH_ky_k)^Ty_k](rH_ky_k)+\\beta[(\\theta{s_k})^Ty_k](\\theta{s_k})=s_k-H_ky_k\\\\ &[\\alpha r^2(y_k^TH_ky_k)+1](H_ky_k)+[\\beta\\theta^2(s_k^Ty_k)-1](s_k)=0\\\\ \\end{aligned}令$[\\alpha r^2(y_k^TH_ky_k)+1]=0,[\\beta\\theta^2(s_k^Ty_k)-1]=0$.得到 \\alpha r^2(y_k^TH_ky_k)+1=0,\\beta\\theta^2(s_k^Ty_k)-1=0\\\\ \\therefore \\alpha r^2=-\\frac{1}{y_k^TH_ky_k},\\beta\\theta^2=\\frac{1}{s_k^Ty_k}所以 \\begin{aligned} H_{k+1}&=H_k + E_k\\\\ &=H_k+\\alpha r^2H_ky_ky_k^TH_k+\\beta \\theta^2s_ks_k^T\\\\ &=H_k-\\frac{H_ky_ky_k^TH_k}{y_k^TH_ky_k}+\\frac{s_ks_k^T}{s_k^Ty_k} \\end{aligned}为什么$H_k^T=H_k$? 因为Hesse矩阵是对称矩阵，而$H_k=B_k^{-1}\\approx G_k^{-1}$ BFGS公式考虑$B_{k+1}=B_k+\\alpha{vv^T}+\\beta{uu^T}$ 代入拟牛顿方程$B_{k+1}s_k=y_k$，得 \\begin{aligned} (B_k+\\alpha{vv^T}+\\beta{uu^T})s_k&=y_k\\\\ \\alpha(v^Ts_k)v+\\beta(u^Ts_k)u&=y_k-B_ks_k \\end{aligned}观察式子，可令$v=ry_k,u=\\theta B_ks_k$，代入上式得 \\begin{aligned} \\alpha((ry_k)^Ts_k)(ry_k)+\\beta((\\theta B_ks_k)^Ts_k)(\\theta B_ks_k)&=y_k-B_ks_k\\\\ (\\alpha r^2(y_k^Ts_k)-1)(y_k)+(\\beta\\theta^2(s_k^TB_ks_k)+1)(B_ks_k))&=0 \\end{aligned}则,可令 \\alpha r^2(y_k^Ts_k)-1 = 0，\\beta\\theta^2(s_k^TB_ks_k)+1=0\\\\ \\therefore \\alpha r^2=\\frac{1}{y_k^Ts_k},\\beta\\theta^2=-\\frac{1}{s_k^TB_ks_k}又 \\begin{aligned} &\\alpha vv^T+\\beta uu^T\\\\ =&\\alpha (ry_k)(ry_k)^T+\\beta(\\theta B_ks_k)(\\theta B_ks_k)^T\\\\ =&\\alpha r^2y_ky_k^T+\\beta\\theta^2B_ks_ks_k^TB_k \\end{aligned}将$\\alpha r^2$和$\\beta\\theta^2$代入，得 \\begin{aligned} B_{k+1}&=B_k + \\alpha vv^T+\\beta uu^T\\\\ &= B_k + \\alpha r^2y_ky_k^T+\\beta\\theta^2B_ks_ks_k^TB_k\\\\ &= B_k + \\frac{y_ky_k^T}{y_k^Ts_k}-\\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k} \\end{aligned}","path":"2021/12/03/数值最优化/负梯度方法和Newton型方法/","date":"12-03","excerpt":"","tags":[{"name":"数学证明","slug":"数学证明","permalink":"https://reiscarlet.github.io/tags/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"}]},{"title":"罚函数、增广拉格朗日函数","text":"[toc] 罚函数罚函数法定义：将约束最优化问题转化为无约束最优化问题去求解 等式约束问题对于约束问题 \\large{ \\begin{align} min\\ & f(x)\\\\ s.t.\\ & g_i(x) = 0 \\end{align} }定义罚函数为 \\large{\\begin{align} min\\ F(x,\\sigma) &= f(x)+\\sigma{P(x)}\\\\ P(x) &= g_i(x)^Tg_i(x) \\end{align}}其中$\\large{\\sigma}$是惩罚因子，$\\large{F(x,\\sigma)}$是罚函数，$\\large{\\sigma{P(x)}}$是惩罚项 该罚函数的特点：对非可行点，当$\\large\\sigma$变大时，惩罚项在罚函数的比重加大，对罚函数求极小相当于使极小值点向可行域靠近。简单的说就是只要你没得到可行解，惩罚项就会越来越大，对罚函数求极小就会迫使所求的x点向极小值点靠近来让惩罚项下降 不等式约束问题对于约束问题 \\begin{align} min\\ & f(x) \\\\ s.t.\\ &h_i(x) \\geq 0 \\end{align}当$\\large h_i(x)\\geq0$时，惩罚项为0；当x不在可行域时，$\\large h_i(x)&lt;0$，所以我们用$\\large{min\\{h_i(x),0\\}}$来分辨x是否在可行域。如果不在，我们还需要加大惩罚因子 所以我们定义惩罚项为$\\large P(x)=\\sigma{\\sum_{i\\in{I}}[min\\{h_i(x),0\\}]}^2$, 一般形式约束问题对于约束问题 \\large{\\begin{align} min\\ & f(x)\\\\ s.t.\\ & g_i(x)=0\\\\ & h_j(x)\\ge 0 \\end{align}}则罚函数为$\\large{P(x)=\\sum_i[g_i(x)]^2 + \\sum_j[min\\{0,h_j(x)\\}]^2}$ 特别注意：惩罚因子是充分大的数，拉格朗日乘子是一个确定的参数，意义不一样 增广拉格朗日定义：增广拉格朗日就是在拉格朗日函数上增加一个惩罚项 等式约束 \\large{\\begin{align} min\\ & f(x)\\\\ s.t.\\ & g_i(x)=0 \\end{align}}其增广拉格朗日函数为：$\\large{\\phi(x,\\lambda,\\sigma)=f(x)+\\lambda^T{g(x)}+\\frac{1}{2}\\sigma{g^T(x)g(x)}}$，其中惩罚因子前的1/2只是为了求导方便 令$\\large{\\nabla_x\\phi(x_k,\\lambda_k,\\sigma_k)}=0$ 得到 \\large{\\begin{align} &\\nabla_xf(x_k)+\\lambda_k\\nabla_xg^T(x_k)+\\sigma_k\\nabla_kg^T(x_k)g(x_k)\\\\ =&\\nabla_kf(x_k)+\\nabla_xg^T(x_k)(\\lambda_k+\\sigma_kg(x_k)) \\\\ =& 0 \\end{align}}其中对惩罚项的导数为 \\large{\\begin{align} 原式&= \\frac{\\partial\\frac{1}{2}\\sigma{g^T(x)g(x)}}{\\partial{x}} \\\\ &= \\frac{1}{2}\\sigma*\\frac{\\part{g^T(x)g(x)}}{\\part{g(x)}} * \\frac{\\part{g(x)}}{\\part{x}}\\\\ &= \\frac{1}{2}\\sigma*2g(x)*\\nabla_xg(x)\\\\ &= \\sigma{g(x)*\\nabla_xg(x)} \\\\ &= \\sigma{g(x)^T\\nabla_xg(x)} \\\\ &= \\sigma{\\nabla_xg^T(x)g(x)} \\end{align}}令$\\large{\\lambda_{k+1}=\\lambda_k+\\sigma_kg(x_k)}$，得到$\\large{\\nabla_xf(x_k)+\\lambda_{k+1}\\nabla_x{g^T(x_k)}=0}$ 不等式约束 \\large{\\begin{align} min\\ & f(x) \\\\ s.t.\\ & h_i(x)\\ge0 \\end{align}}引入松弛变量a，使得$\\large{h_i(x)-a=0}(a\\ge0)$ 则原问题化为 \\large{\\begin{align} min\\ \\phi(x,\\lambda,\\sigma)&=f(x)+\\lambda^T(h_i(x)-a)+\\frac{1}{2}\\sigma{(h_i(x)-a)^T(h_i(x)-a)} (1) \\end{align}}消除松弛变量a，得到 \\large{\\begin{align} min\\ \\phi(x,\\lambda,\\sigma,a)&= f(x) + \\frac{\\sigma}{2}(\\frac{2}{\\sigma}\\lambda^T(h_i(x)-a)+||(h_i(x)-a)||^2)\\\\ &= f(x) + \\frac{\\sigma}{2}((h_i(x)-a+\\frac{\\lambda}{\\sigma})^2-(\\frac{\\lambda}{\\sigma})^2)(2)\\\\ \\end{align}}当x确定时，求a的最小值，此时与a无关的因为不会影响可以忽略掉 \\large{\\begin{align} min_a\\ \\phi(x,\\lambda,\\sigma) &= (h_i(x)-a+\\frac{\\lambda}{\\sigma})^2\\\\ s.t. a&\\ge0 \\\\ \\therefore a_i &= \\frac{1}{\\sigma}max\\{0,\\sigma{h_i(x)}+\\lambda\\} \\end{align}}当$\\large{\\sigma{h_i(x)}+\\lambda\\ge0}$时，也就是$\\large{a={h_i(x)}+\\frac{\\lambda}{\\sigma}}$，带入(2)式得到 \\large{\\begin{align} \\phi(x,\\lambda,\\sigma) &= f(x)-\\frac{\\sigma}{2}(\\frac{\\lambda}{\\sigma})^2\\\\ &=f(x) - \\frac{\\lambda^2}{2\\sigma}\\\\ \\therefore\\nabla_x\\phi(x,\\lambda,\\sigma)&=\\nabla_xf(x) \\end{align}}当$\\large{\\sigma{h_i(x)}+\\lambda&lt;0}$时，$\\large{a=0}$,带入(2)式，得到 \\large{\\begin{align} \\phi(x,\\lambda,\\sigma)&=f(x)+\\frac{\\sigma}{2}(h_i(x)+\\frac{\\lambda}{\\sigma})^2-\\frac{\\sigma}{2}(\\frac{\\lambda}{\\sigma})^2\\\\ &=f(x)-\\frac{\\lambda^2}{2\\sigma} + \\frac{1}{2\\sigma}(\\sigma{h_i(x)}+\\lambda)^2\\\\ \\therefore \\nabla_x\\phi(x,\\lambda,\\sigma) &= \\nabla_xf(x) + (\\sigma{h_i(x)}+\\lambda)\\nabla_xh_i(x) \\end{align}}综上所述： \\large{ \\nabla_x\\phi(x,\\lambda,\\sigma) = \\left\\{\\begin{align} &\\nabla_xf(x),&\\sigma{h_i(x)}+\\lambda\\ge0 \\\\ &\\nabla_xf(x) + (\\sigma{h_i(x)}+\\lambda)\\nabla_xh_i(x),&\\sigma{h_i(x)}+\\lambda","path":"2021/12/03/数值最优化/罚函数方法/","date":"12-03","excerpt":"","tags":[]},{"title":"为什么梯度方向是函数值上升最快的方向？","text":"[TOC] 一元函数的导数首先我们要明确，导数除了代表函数在某点的切线的斜率外，还表示函数在该点的变化率 $\\Large f(x_0)’ = lim_{\\Delta x\\rightarrow 0}\\frac{\\Delta y}{\\Delta x} = lim_{\\Delta x\\rightarrow 0}\\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}$ 即反应了函数值沿着x轴的方向变化率。 多元函数的偏导数拥有多个变量时的函数为多元函数，以二元函数为例子 对于二元函数的偏导数： $\\large f_x(x,y)$指的是函数在y方向不变，函数值沿着x轴方向的变化率，即 \\large f_x(x_0,y_0)=lim_{\\Delta x\\rightarrow 0}\\frac{f(x_0+\\Delta x,y_0)-f(x_0,y_0)}{\\Delta x}$\\large f_y(x,y)$指的是函数在x方向不变，函数值沿着y轴方向的变化率 \\large f_y(x_0,y_0)=lim_{\\Delta x\\rightarrow 0}\\frac{f(x_0,y_0+\\Delta y)-f(x_0,y_0)}{\\Delta y}二元函数的图像是一个曲面，偏导数就是多元函数沿着某一个坐标轴的变化率，如果我们要考虑任意方向的变化率，是无法求解了，这就引出了方向导数 方向导数方向导数就是沿着每个方向的函数值的变化率 以二元函数为例子： 单位向量的方向： 对于的坐标$\\large(x,y,z)$，设该向量和$\\large x,y,z$轴正方向的夹角为$\\large\\alpha,\\beta,\\gamma$，则由$\\large x，y，z$轴的单位向量，则 \\large cos\\alpha = \\frac{(x,y,z)·(1,0,0)}{\\sqrt{x^2+y^2+z^2}} = \\frac{x}{\\sqrt{x^2+y^2+z^2}}\\\\ \\large cos\\beta = \\frac{(x,y,z)·(0,1,0)}{\\sqrt{x^2+y^2+z^2}} = \\frac{y}{\\sqrt{x^2+y^2+z^2}}\\\\ \\large cos\\gamma = \\frac{(x,y,z)·(0,0,1)}{\\sqrt{x^2+y^2+z^2}} = \\frac{z}{\\sqrt{x^2+y^2+z^2}}\\\\ \\large (cos\\alpha,cos\\beta,cos\\gamma)=\\frac{1}{\\sqrt{x^2+y^2+z^2}}(x,y,z)所以$\\large (cos\\alpha,cos\\beta, cos\\gamma)$是OP的同向的单位向量 所以对二元函数，单位向量为$\\large (cos\\alpha, cos\\beta)$ 求参数方程： 设两点$\\large \\vec{P}=(x,y), \\vec{P_0}=(x_0,y_0)$ 直线$\\large l=\\vec{P_0P}=(x-x_0,y-y_0)$与向量$\\large e_l=(cos\\alpha,cos\\beta)$平行，且方向相同 所以 \\large \\vec{P_0P} || e_l \\rightarrow \\vec{P_0P}=t\\cdot e_l \\\\ \\therefore \\large(x-x_0, y-y_0)=t\\cdot (cos\\alpha, cos\\beta)\\\\ \\therefore \\large x = x_0 + tcos\\alpha, y = y_0 + tcos\\beta \\\\ \\therefore \\large P = (x,y) = (x_0 + tcos\\alpha, y_0 + tcos\\beta)所以沿着指向l的方向导数为 $\\Large \\frac{\\partial f}{\\partial l}|_{(x_0,y_0)} = lim_{t\\rightarrow 0}\\LARGE\\frac{f(x_0+tcos\\alpha, y_0+tcos\\beta)-f(x_0,y_0)}{t}$ 即是函数在指向l的方向上的方向导数$\\Large \\frac{\\partial f}{\\partial l}|_{(x_0,y_0)}$ 梯度如果函数$\\large z = f(x,y)$可微分，那么函数沿着该点任意方向的方向导数必然存在 因为可微分，所以 \\begin{align}\\large{ f(x_0+\\Delta x, y_0+\\Delta y)-f(x_0,y_0)\\\\ =f(x_0+\\Delta x, y_0+\\Delta y)-f(x_0+\\Delta x, y_0) + f(x_0+\\Delta x, y_0)-f(x_0,y_0)\\\\ =f_x(x_0,y_0)\\Delta x + f_y(x_0,y_0)\\Delta y + o(\\sqrt{(\\Delta x)^2 + (\\Delta y)^2}) \\\\ 根据方向导数的定义，令\\Delta x = tcos\\alpha,\\Delta y = tcos\\beta\\ 有\\\\ f_x(x_0,y_0)tcos\\alpha + f_y(x_0,y_0)tcos\\beta + o(\\sqrt{(tcos\\alpha)^2 + (tcos\\beta)^2}) \\\\ = f_x(x_0,y_0)tcos\\alpha + f_y(x_0,y_0)tcos\\beta \\\\ \\therefore \\frac{\\partial f}{\\partial l}|_{(x_0,y_0)}=lim_{t\\rightarrow 0}\\frac{f_x(x_0,y_0)tcos\\alpha + f_y(x_0,y_0)tcos\\beta}{t} \\\\ = f_x(x_0,y_0)cos\\alpha + f_y(x_0,y_0)cos\\beta \\\\ = (f_x(x_0,y_0),f_y(x_0,y_0))\\cdot (cos\\alpha,cos\\beta) }\\end{align}令梯度为$\\large grad f = (f_x(x_0,y_0),f_y(x_0,y_0))$ 所以梯度与方向的内积为：$\\large |f_x(x_0,y_0),f_y(x_0,y_0)|\\cdot |cos\\alpha,cos\\beta|cos\\alpha$，其中α是夹角，所以当$\\large cos\\alpha = 1即\\alpha = 0$时取得最大，即两个方向平行时取得。 所以当方向为梯度的方向时，函数值上升最快。反方向是下降最快","path":"2021/12/03/数值最优化/梯度方向/","date":"12-03","excerpt":"","tags":[]},{"title":"序列二次规划","text":"[toc] 介绍因为等式约束二次规划问题的Lagrange函数是二次函数，求Lagrange函数的稳定点就是求KKT方程组，而一般等式约束的最优化问题的Lagrange函数一般事非线性函数，就需要用迭代的方法求稳定点 求解一般等式约束问题的每一步迭代都要求解一个二次规划问题，该方法称为序列二次规划（Sequential Quadratic Programming）方法 Lagrange-Newton的方法对等式约束最优化问题 \\begin{aligned} min\\ &f(x)\\\\ s.t.\\ &g(x)=0 \\end{aligned}它的Lagrange函数为$L(x,\\lambda)=f(x)-\\lambda{g(x)}$ 且满足KKT条件 \\nabla L(x,\\lambda)= \\begin{bmatrix}\\nabla_xL(x,\\lambda)\\\\\\nabla_\\lambda L(x,\\lambda)\\end{bmatrix}= \\begin{bmatrix}\\nabla f(x) - \\lambda\\nabla g(x)\\\\-g(x)\\end{bmatrix}=0 \\quad假设当前迭代点为$(x_k,\\lambda_k)$，该点的增量为$(d_x,d_\\lambda)$ 则$\\nabla{L(x_k+d_x,\\lambda_k+d_\\lambda)}在(x_k,\\lambda_k)$的Taylor展开为 \\nabla{L(x_k+d_x,\\lambda_k+d_\\lambda)}\\approx \\nabla{L(x_k,\\lambda_k)}+ \\nabla^2L(x_k,\\lambda_k) \\begin{bmatrix}d_k\\\\d_\\lambda\\end{bmatrix}=0即要$\\nabla^2L(x_k,\\lambda_k)\\begin{bmatrix}d_k\\\\d_\\lambda\\end{bmatrix}=-\\nabla{L(x_k,\\lambda_k)}$,其中 \\nabla^2L(x_k,\\lambda_k)= \\begin{bmatrix}\\nabla^2f(x_k)-\\lambda_k\\nabla^2g(x_k) & -\\nabla{g(x_k)}\\\\-\\nabla{g(x_k)}^T & 0\\end{bmatrix}所以 \\begin{bmatrix}\\nabla^2f(x_k)-\\lambda_k\\nabla^2g(x_k) & -\\nabla{g(x_k)}\\\\-\\nabla{g(x_k)}^T & 0\\end{bmatrix} \\begin{bmatrix}d_x \\\\ d_\\lambda \\end{bmatrix}= \\begin{bmatrix} -\\nabla{f(x_k)}+\\lambda_k\\nabla{g(x_k)}\\\\g(x_k) \\end{bmatrix}该方程的系数矩阵为KKT矩阵，若记$\\lambda_{k+1}=\\lambda_k+d_\\lambda,d_k=d_x$,带入得到方程组为 \\begin{bmatrix}\\nabla^2f(x_k)-\\lambda_k\\nabla^2g(x_k) & -\\nabla{g(x_k)}\\\\-\\nabla{g(x_k)}^T & 0\\end{bmatrix} \\begin{bmatrix}d_k\\\\\\lambda_{k+1}\\end{bmatrix}= \\begin{bmatrix}-\\nabla{f(x_k)}\\\\g(x_k)\\\\\\end{bmatrix}解出$d_k,\\lambda_{k+1}$，从而$x_{k+1}=x_k+d_k$ Lagrange-Newton方法的等价形式令$W_k=\\nabla^2f(x_k)-\\lambda_k\\nabla^2g(x_k)$ 考虑下面的二次规划问题： \\begin{aligned} &min\\ q_k(d)=\\frac{1}{2}d^TW_kd+\\nabla{f(x_k)}^Td+f(x_k)\\\\ &s.t.\\ g(x_k)+\\nabla{g(x_k)}^Td=0 \\end{aligned}当$\\nabla{g(x_k)}$列满秩且$d^TW_kd&gt;0,\\nabla{g(x_k)}^Td=0且d\\neq0$时，有唯一解$d_k,\\lambda_{k+1}$，且满足KKT方程组 \\left\\{ \\begin{aligned} & W_kd+\\nabla{f(x_k)}-\\lambda\\nabla{g(x_k)}=0\\\\ & \\nabla{g(x_k)}^Td+g(x_k)=0 \\end{aligned} \\right.即是 \\begin{bmatrix}W_k & -\\nabla{g(x_k)}\\\\-\\nabla{g(x_k)}^T & 0\\end{bmatrix} \\begin{bmatrix}d\\\\\\lambda\\end{bmatrix}= \\begin{bmatrix}-\\nabla{f(x_k)}\\\\g(x_k)\\end{bmatrix}当求解上式的$d=d_k,\\lambda=\\lambda_{k+1}$时，刚好是Lagrange-Newton的KKT方程组的形式。所以上述是Lagrange-Newton方法的等价形式 解一般约束最优化问题的序列二次规划方法考虑一般约束最优化问题 \\begin{aligned} min\\ &f(x)\\\\ s.t.\\ &g_i(x)=0,i\\in J\\\\ &g_i(x)\\ge0,i\\in I \\end{aligned}则由上面可知，为求解上式，在$x_k$处，我们需要求解下面的子问题 \\begin{aligned} min\\ &\\frac{1}{2}d^TW_kd+\\nabla{f(x_k)}^Td+f(x_k)\\\\ s.t.\\ &g(x_k)+\\nabla{g(x_k)}^Td=0,i\\in J\\\\ &g(x_k)+\\nabla{g(x_k)}^Td\\ge0,i\\in I \\end{aligned}对上式求解得到$d_k,\\lambda_{k+1}$；这是一个二次规划问题，可以用我们二次规划的方法求解得到。对一般约束最优化问题，每一次迭代都要解一个二次规划的子问题，所以称该方法为序列二次规划（SQP）方法","path":"2021/12/03/数值最优化/序列二次规划/","date":"12-03","excerpt":"","tags":[]},{"title":"共轭梯度法","text":"[toc] 共轭方向我们首先看一个函数$f(x)=x_1^2+x_2^2$，图像是一个圆 在$x_1,x_2$的坐标轴中，由于$x_1,x_2$是解耦合的,即是$x_1,x_2$是对正交向量，$x_1,x_2$构成了一个向量空间，也就是$x_1,x_2$构成这个空间的基，所以我们可以先沿着$x_1$的方向走到最优点所在的$x_1$的坐标，然后在沿着$x_2$的方向走，最后到达最优点。在这迭代的过程中，两次方向$g_{k+1}g_k=0$ 但是如果这个函数不是刚好一个圆呢？如果是倾斜一点的话，相当于加上了$ax_1x_2$耦合了$x_1,x_2$，因为$g_{k+1}g_k=0$，下一步和上一步的方向是垂直的，我们发现我们没办法先沿着$x_1$走然后再沿着$x_2$走，也就是两步没办法找到最优点了。 这时候我们引入共轭，即通过对空间的线性变换，在变换的过程中，使得新的空间下，$ax_1x_2$被消除，从而对$x_1,x_2$解耦合，在新的空间中，通过变换的$\\tilde x_1,\\tilde x_2$是$x_1,x_2$的共轭方向，然后我们就可以沿着$\\tilde x_1$走，然后再向$\\tilde x_2$走，直接两步走到最优点 又$d_kd_{k+1}=0$是在度量空间$I$下，相当于$d_kId_{k+1}=0$,通过线性变换$Q$，使得度量空间变为$Q$，所以有$d_kQd_{k+1}=0$,注意在新的空间下，$d_kd_{k+1}=0$仍然成立，因为我们只是改了表示的方法，事实上性质没有改变 子空间拓展定理设$G$是正定矩阵，$d_0,d_1,…,d_{n-1}$是关于$G$的共轭方程组，则对于$f(x)=\\frac{1}{2}x^TGx+b^Tx$，第k+1步得到的迭代点处梯度方向是之前所有的搜索方向张成的线性空间正交，即是$g_k^Td_j=0,j=0,…,k-1$。 证明：对所有$i\\leq n-1$都有$g_{i+1}^Td_j=0,j=0,1,…,i$ $j=i$时，根据精确线搜索，有$\\Large\\frac{\\partial}{\\partial\\alpha}\\normalsize f(x_i+\\alpha d_i)=\\nabla f(x_{i+1})^Td_i=g_{i+1}^Td_i=0$ $j&lt;i$时 \\begin{aligned} g_{i+1}^Td_j &= g_{i+1}^Td_j + \\sum_{k=j+1}^i(g_k^Td_j-g_k^Td_j)\\\\ &=g_{i+1}^Td_j+g_{j+1}^Td_j-g_{j+1}^Td_j + \\sum_{k=j+1}^i(g_k^Td_j-g_k^Td_j)\\\\ &=g_{j+1}^Td_j + (-g_{j+1}+g_{j+1}+...+g_i+g_{i+1})^Td_j-\\sum_{k=j+1}^ig_k^Td_j \\\\ &=g_{j+1}^Td_j+\\sum_{k=j+2}^{i+1}g_{k}^Td_j-\\sum_{k=j+1}^ig_k^Td_j\\\\ &=g_{j+1}^Td_j+\\sum_{k=j+1}^i(g_{k+1}-g_k)^Td_j\\quad(g_{j+1}^Td_j=0)\\\\ &=\\sum_{k=j+1}^i(g_{k+1}-g_k)^Td_j\\\\ &=\\sum_{k=j+1}^i[G(x_{k+1}-x_k)]^Td_j\\\\ &=\\sum_{k=j+1}^i\\alpha_kd_kGd_j=0\\quad(d_kGd_j=0,共轭) \\end{aligned} 我们第$k+1$次得到的迭代点处的梯度值与之前所有的搜索方向正交，也就是说之前所有的搜索方向在梯度方向上分量都为0 共轭梯度法前置知识因为共轭向量组中的向量一定线性无关和子空间拓展可知，$d_k,g_k$不在$d_i,i=0,…,k-1$生成的子空间，又$g_k^Td_j=0,j=0,…,k-1$，$g_k$可以与$d_0,…,d_{k-1}$张成一个$k+1$维子空间，所以$d_k$为$g_k,d_0,…,d_{k-1}$的线性组合，其中$g_k$的系数取-1 建立$d_k=-g_k+\\sum_{i=0}^{k-1}\\beta_i^{(k-1)}d_i$ 代入$d_k^TGd_j=0$,得到$d_k=(-g_k+\\sum_{i=0}^{k-1}\\beta_i^{(k-1)}d_i)^TGd_j=0$ 由$d_i,d_j(i\\neq j)$具有共轭性,可得$\\beta_j^{(k-1)}=\\Large\\frac{g_k^TGd_j}{d_j^TGd_j},\\normalsize j=0,…,k-1$ 由于$x_{j+1}=x_j+\\alpha_jd_j$,且$g_j=Gx_j+b$ 对$\\beta_j^{(k-1)}$的分子同乘于$\\alpha_j$,得到 \\begin{aligned} \\alpha_j g_k^TGd_j &= g_k^TG\\alpha_jd_j\\\\ &=g_k^TG(x_{j+1}-x_j)\\\\ &=g_k^T(g_{j+1}-g_j) \\end{aligned}又 \\begin{aligned} &\\because d_k=-g_k+\\sum_{i=0}^{k-1}\\beta_i^{(k-1)}d_i\\\\ &\\therefore g_j=-d_j + \\sum_{i=0}^{j-1}\\beta_i^{(k-1)}d_i\\\\ &\\because g_kd_j=0\\\\ &\\therefore g_k(-g_j+\\sum_{i=0}^{j-1}\\beta_i^{(k-1)}d_i)=0\\\\ &\\therefore g_kg_j=\\sum_{i=0}^{j-1}\\beta_i^{(k-1)}g_kd_i=0\\\\ &\\therefore g_kg_j=0 \\end{aligned}所以 g_k^T(g_{j+1}-g_j)=\\left\\{ \\begin{aligned} &0,&j=0,...,k-2\\\\ &g^T_k(g_k-g_{k-1}),&j=k-1 \\end{aligned} \\right.所以 \\begin{aligned} d_k&=-g_k+\\sum_{i=0}^{k-1}\\beta_i^{(k-1)}d_i\\\\ &=-g_k+\\beta_{k-1}d_{k-1} \\end{aligned} 从上面我们可以知道 搜索方向都是共轭的 搜索方向是$-g_k$和$d_{k-1}$的线性组合 求βHestenes-Stiefel公式对$d_k=-g_k+\\beta_{k-1}d_{k-1}$,等式两边同乘$d_{k-1}^TQ$，且$d_{k-1}^TQd_k=0$ \\begin{aligned} \\therefore d_{k-1}^TQd_k&= -d_{k-1}^TQg_k+d_{k-1}^TQ\\beta_{k-1}d_{k-1}\\\\ 0 &=-d_{k-1}^TQg_k+d_{k-1}^TQ\\beta_{k-1}d_{k-1}\\\\ \\therefore \\beta_{k-1}^{HS}&=\\frac{d_{k-1}^TQg_k}{d_{k-1}^TQd_{k-1}}\\\\ &=\\frac{d_{k-1}^TGg_k}{d_{k-1}^TGd_{k-1}}\\\\ &=\\frac{g_k^TGd_{k-1}}{d_{k-1}^TGd_{k-1}} \\end{aligned}Crowder-Wolfe公式 \\begin{aligned} \\because g_{k+1}-g_k&=G(x_{k+1}-x_k)=\\alpha{Gd_k}\\\\ \\therefore \\beta^{CW}_{k-1}&=\\frac{g_k^TGd_{k-1}}{d_{k-1}^TGd_{k-1}}\\\\ &=\\frac{g_k^T(g_k-g_{k-1})}{d_{k-1}^T(g_k-g_{k-1})}\\\\ \\end{aligned}Fletcher-Reeves公式对$d_k=-g_k+\\beta_{k-1}d_{k-1}$ 有 \\begin{aligned} d_k&=-g_k+\\beta_{k-1}d_{k-1}\\\\ d_k^T&=-g_k^T+d_{k-1}^T\\beta_{k-1}\\\\ d_k^Tg_{k+1}&=-g_k^Tg_{k+1}+d_{k-1}^T\\beta_{k-1}g_{k+1}\\\\ \\therefore &d_k^Tg_{k+1}=d_{k-1}^Tg_{k+1}=0\\\\ \\therefore &g_k^Tg_{k+1}=g_{k+1}^Tg_k=0 \\end{aligned}代入CW得 \\begin{aligned} \\beta_{k-1}^{CW}&=\\frac{g_k^T(g_{k}-g_{k-1})}{d_{k-1}^T(g_{k}-g_{k-1})}\\\\ &=\\frac{g_k^Tg_k}{-d_{k-1}g_{k-1}}\\\\ \\because-d_{k-1}&g_{k-1}=g_{k-1}^Tg_{k-1} \\\\ &=\\frac{g_k^Tg_k}{g_{k-1}^Tg_{k-1}}\\\\ \\therefore \\beta_{k-1}^{FR}&=\\frac{g_k^Tg_k}{g_{k-1}^Tg_{k-1}} \\end{aligned}其中 \\begin{aligned} d_{k-1}^Tg_{k-1}&=(-g_{k-1}+\\beta_{k-2}d_{k-2})^Tg_{k-1}\\\\ &=-g_{k-1}^Tg_{k-1}+d_{k-2}^T\\beta_{k-2}g_{k-1}\\\\ &=-g_{k-1}^Tg_{k-1}+\\beta_{k-2}d_{k-2}^Tg_{k-1}\\\\ \\because &\\quad d_{k-2}^Tg_{k-1}=0\\\\ \\therefore &\\quad d_{k-1}^Tg_{k-1}=-g_{k-1}^Tg_{k-1} \\end{aligned}Polak-Ribiere-Polyak公式因为 \\begin{aligned} \\beta_{k-1}^{CW}&=\\frac{g_k^T(g_k-g_{k-1})}{d_{k-1}^T(g_k-g_{k-1})}\\\\ &=\\frac{g_k^T(g_k-g_{k-1})}{d_{k-1}^Tg_k-d_{k-1}^Tg_{k-1}}\\\\ \\because &d_{k-1}^Tg_k=0\\\\ &d_{k-1}^Tg_{k-1}=g_{k-1}^Tg_{k-1}\\\\ \\therefore g_{k-1}^{PRP}&=\\frac{g_k^T(g_k-g_{k-1})}{g_{k-1}^Tg_{k-1}} \\end{aligned}Conjugate-Descent公式 \\begin{aligned} &\\beta_{k-1}^{CW}=\\frac{g_k^T(g_{k}-g_{k-1})}{d_{k-1}^T(g_{k}-g_{k-1})}\\\\ \\because &g_k^Tg_{k-1}=0\\\\ &d_{k-1}^Tg_{k}=0\\\\ \\therefore&\\beta^{CD}_{k-1}=-\\frac{g_k^Tg_k}{d_{k-1}^Tg_{k-1}} \\end{aligned}Dai-Yuan公式 \\begin{aligned} &\\beta_{k-1}^{CW}=\\frac{g_k^T(g_{k}-g_{k-1})}{d_{k-1}^T(g_{k}-g_{k-1})}\\\\ \\because &g^T_kg_{k-1}=0\\\\ \\therefore &\\beta^{DY}_{k-1}=\\frac{g_k^Tg_k}{d_{k-1}^T(g_{k}-g_{k-1})} \\end{aligned}求步长α \\begin{aligned} \\because &g_{k+1}-g_k=G(x_{k+1}-x_k)=\\alpha_kGd_k\\\\ \\therefore &d_k^T(g_{k+1}-g_k)=\\alpha_kd_k^TGd_k\\\\ &\\alpha_k=\\frac{d_k^T(g_{k+1}-g_k)}{d_k^TGd_k}\\\\ &\\quad=\\frac{d_k^Tg_k}{d_k^TGd_k}\\\\ &\\quad=\\frac{g_k^Tg_k}{d_k^TGd_k} \\end{aligned}","path":"2021/12/03/数值最优化/共轭梯度法/","date":"12-03","excerpt":"","tags":[{"name":"数学证明","slug":"数学证明","permalink":"https://reiscarlet.github.io/tags/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"}]},{"title":"二次规划","text":"[toc] 二次规划二次规划问题（Quadratic Programming，QP）一般描述为： \\begin{align} min\\ q(x)&=\\frac{1}{2}x^TGx+h^Tx,\\\\ s.t.\\ a_i^Tx &= b_i, i\\in I\\\\ a_i^Tx &\\ge b_i, i\\in J \\end{align}分类： 凸二次规划问题：G半正定，问题有全局解 严格凸二次规划问题：G正定，问题有唯一全局解 一般二次规划问题：G不定，问题有稳定点或局部解 等式约束二次规划问题等式而约束二次规划问题形式为： \\begin{aligned} min\\ f(x) &= \\frac{1}{2}x^TGx+g^Tx\\\\ s.t.\\ A^Tx &= b \\end{aligned}变量消去方法 通过将x的分量分成基本变量$\\large{x_B}$与非基本变量$\\large{x_N}$两部分，通过等式约束将基本变量用非基本变量表示出； 再将基本变量带入目标函数，从而消去基本变量，把问题化为一个关于非基本变量的无约束最优化问题； 最后求解无约束最优化问题的方法解之 例如，对X分块，A、G、g对应的也分块，得到 \\begin{align} &x=\\begin{bmatrix}x_B\\\\x_N\\end{bmatrix}, &A=\\begin{bmatrix}A_B\\\\A_N\\end{bmatrix}\\\\ &G=\\begin{bmatrix}G_{BB}&G_{BN}\\\\G_{NB}&G_{NN}\\end{bmatrix}, &g=\\begin{bmatrix}g_B\\\\g_N\\end{bmatrix} \\end{align}则等式约束化为$A^Tx=b\\rightarrow A_B^Tx_B+A_N^Tx_N = b$ 所以基本变量为$x_B=A^{-T}_B(b-A^T_Nx_N)$ 带入目标函数得到 \\begin{align} min\\ f(x) &= \\frac{1}{2}x^TGx+g^Tx\\\\ &=\\frac{1}{2} \\begin{bmatrix}x_B&x_N\\end{bmatrix} \\begin{bmatrix}G_{BB}&G_{BN}\\\\G_{NB}&G_{NN}\\end{bmatrix} \\begin{bmatrix}x_B\\\\x_N\\end{bmatrix}+ \\begin{bmatrix}g_B&g_N\\end{bmatrix} \\begin{bmatrix}x_B\\\\x_N\\end{bmatrix} \\\\ &=\\frac{1}{2} \\begin{bmatrix}A_B^{-T}(b-A^T_Nx_N)&x_N\\end{bmatrix} \\begin{bmatrix}G_{BB}&G_{BN}\\\\G_{NB}&G_{NN}\\end{bmatrix} \\begin{bmatrix}A_B^{-T}(b-A^T_Nx_N)\\\\x_N\\end{bmatrix} \\\\&\\quad+\\begin{bmatrix}g_B&g_N\\end{bmatrix} \\begin{bmatrix}A_B^{-T}(b-A^T_Nx_N)\\\\x_N\\end{bmatrix} \\\\ &=\\frac{1}{2}\\{(A_B^{-T}(b-A_N^Tx_N)G_{BB}+x_NG_{NB})A_B^{-T}(b-A^T_Nx_N) \\\\&\\quad+(A_B^{-T}(b-A^T_Nx_N)G_{BN}+x_NG_{NN})x_N\\} \\\\&\\quad+g_BA_B^{-T}(b-A_N^Tx_N)+g_Nx_N \\\\ &=\\frac{1}{2}((A_B^{-T}bG_{BB}-A_B^{-T}A_N^Tx_NG_{BB}+x_NG_{NB})A_B^{-T}(b-A_N^Tx_N)\\\\&\\quad+ (A_B^{-T}bG_{BN}-A_B^{-T}A_N^Tx_NG_{BN}+x_NG_{NN})x_N)\\\\&\\quad+ g_BA_B^{-T}b-g_BA_B^{-T}A_N^Tx_N+g_Nx_N\\\\ &=\\frac{1}{2}(A_B^{-T}bG_{BB}A_B^{-T}b - A_B^{-T}A_N^Tx_NG_{BB}A_B^{-T}b + x_NG_{NB}A_B^{-T}b \\\\&\\quad - A_B^{-T}bG_{BB}A_B^{-T}A_N^Tx_N + A_B^{-T}A_N^Tx_NG_{BB}A_B^{-T}A_N^Tx_N - x_NG_{NB}A_B^{-T}A_N^Tx_N\\\\&\\quad+ A_B^{-T}bG_{BN}x_N-A_B^{-T}A_N^Tx_NG_{BN}x_N+x_NG_{NN}x_N)\\\\&\\quad+ g_BA_B^{-T}b-g_BA_B^{-T}A_N^Tx_N+g_Nx_N\\\\ \\end{align}因为现在问题化为一个关于非基本变量的无约束最优化问题，所以我们只需要找出与$x_N$有关的项，其他均为常数项，最优化问题中不影响结果 找出所有$x_N^TAx_N$形式的项，得到$G_N = G_{NN}+A_NA_B^{-1}G_{BB}A_B^{-T}A_N^T-G_{NB}A_B^{-T}A_N^T - A_NA_B^{-1}G_{BN}$ 找出所有$Ax_N$形式的项，得到$g_N =g_N - A_NA_B^{-1}g_B + (G_{NB}-A_NA_B^{-1}G_{BB})A_B^{-T}b$ 所以关于非基本变量的无约束最优化问题形式为$q(x_N) = \\frac{1}{2}x_N^TG_Nx_N + g_N^Tx_N$ 求解该无约束最优化问题$min\\ f(x_N)$ 若$G_N$正定，则存在唯一解，$x_N^*=-G_N^{-1}g_N$ 求$x^*$处的拉格朗日因子$\\nabla{f(x^*)=\\lambda{A}}$，即 \\begin{align} &\\begin{bmatrix}G_{BB}&G_{BN}\\\\G_{NB}&G_{NN} \\end{bmatrix} \\begin{bmatrix}x^*_B\\\\x^*_N\\end{bmatrix} +\\begin{bmatrix}g_B\\\\g_N\\end{bmatrix} =\\begin{bmatrix}A_B\\\\A_N\\end{bmatrix}\\lambda^*\\\\ &\\begin{bmatrix}G_{BB}x^*_B+G_{BN}x^*_N \\\\ G_{NB}x^*_B+G_{NN}x^*_N \\end{bmatrix} +\\begin{bmatrix}g_B\\\\g_N\\end{bmatrix} =\\begin{bmatrix}A_B\\\\A_N\\end{bmatrix}\\lambda^*\\\\ &\\begin{bmatrix}G_{BB}x^*_B+G_{BN}x^*_N+g_B \\\\ G_{NB}x^*_B+G_{NN}x^*_N+g_N \\end{bmatrix} =\\begin{bmatrix}A_B\\\\A_N\\end{bmatrix}\\lambda^*\\\\ \\end{align}取第一式$A_B^{-1}(G_{BB}x^_B+G_{BN}x_N^+g_B)=\\lambda^*$ 变量消除法的缺点：当$A_B$接近奇异矩阵时，求解过程的数值不稳定 零空间方法零空间方法又称为广义变量消去法 像空间R(A)是矩阵的列向量张成的空间，核空间又称为矩阵的零空间N(A^T) 假定A是满秩，则将A分为两个互补的子空间，$R^n=R(A)+N(A^T)$，设$Y=[y_1,..,y_m]$是$R(A)$的一组线性无关向量，$Z=[z_1,…,z_{n-m}]$是$N(A^T)$的一组线性无关向量，我们可以选择$A,Z$使得$[Y\\quad{Z}]$非奇异 并满足$A^TY=I,A^TZ=0$ 令$x=Yx_y+Zx_z$，则$A^Tx=b$化为$A^TYx_y+A^TZx_z=b$ 所以$x_y=b$,则$x=Yb+Zx_z$，带入目标函数，得 \\begin{align} 令f(x)&= min\\ \\frac{1}{2}x^TGx+g^Tx\\\\ &= \\frac{1}{2}(Yb+Zx_z)^TG(Yb+Zx_z)+g^T(Yb+Zx_z)\\\\ &= \\frac{1}{2}x_z^TZ^TGZx_z+ (g+GYb)^TZx_z +\\frac{1}{2}(2g+GYb)^TYb\\\\ \\end{align}其中$Z^TGZ$为简约Hesse矩阵，若$Z^TGZ$正定，该问题的唯一解满足 \\begin{align} \\nabla{f(x)} &= Z^TGZx_z + (g+GYb)^TZ=0 \\end{align}得到$(Z^TGZ)x_z=-((g+GYb)^TZ)^T = -Z^T(g+GYb)$ 最优解$x^=Yb+Zx^_z$,对应的$\\lambda^$满足$A\\lambda^=Gx^*+g$ 两边同左乘$Y^T$得到，$(A^TY)^T\\lambda^=Y^T(Gx^+g)$，则$\\lambda^=Y^T(Gx^+g)$ 零空间法适合解n-m较小的问题 如何选取满足条件的Y和Z： 用QR分解的方法： $A=Q\\begin{bmatrix}R\\\\0\\end{bmatrix}=\\begin{bmatrix}Q_1&amp;Q_2\\end{bmatrix}\\begin{bmatrix}R\\\\0\\end{bmatrix}=Q_1R$ 取$Y=Q_1R^{-T},\\quad Z=Q_2$，则Y和Z满足条件 一般选取方法： 任意选择满足$\\begin{bmatrix}A&amp;V\\end{bmatrix}$非奇异的$V\\in{R^{n(n-m)}}$,设$\\begin{bmatrix}A&amp;V\\end{bmatrix}^{-1}=\\begin{bmatrix}Y^T\\\\Z^T\\end{bmatrix}$,其中$Y\\in{\\mathbb{R^{nm}}},Z\\in{\\mathbb{R^{n*(n-m)}}}$，则Y和Z满足条件 Lagrange方法等式约束二次规划的Lagrange函数为： L(x,\\lambda) = \\frac{1}{2}x^TGx+g^Tx-\\lambda(A^Tx-b)其KKT条件为： \\left\\{\\begin{aligned} & Gx+g-\\lambda{A} = 0\\\\ & A^Tx-b=0 \\end{aligned}\\right.表示为KKT方程组为： \\begin{bmatrix}G&-A\\\\-A^T&0\\end{bmatrix} \\begin{bmatrix}x\\\\\\lambda\\end{bmatrix}= \\begin{bmatrix}-g\\\\-b\\end{bmatrix}其中$\\begin{bmatrix}G&amp;-A\\-A^T&amp;0\\end{bmatrix}$为KKT矩阵 设A满秩，$Z$满足$AZ=0$，也即$Z$的列组成了A的零空间，那么$Z^TGZ$是正定，则KKT矩阵非奇异且有唯一解，证明如下 如果我们有$\\begin{bmatrix}G&amp;-A\\-A^T&amp;0\\end{bmatrix}\\begin{bmatrix}u\\\\v\\end{bmatrix}=0$ 得到$A^Tu=0$ 则$\\begin{bmatrix}u^T&amp;v^T\\end{bmatrix}\\begin{bmatrix}G&amp;-A\\-A^T&amp;0\\end{bmatrix}\\begin{bmatrix}u\\\\v\\end{bmatrix}=u^TGu=0$ 则对简约Hesse矩阵$Z^TGZ$，$u^TGu=u^TZ^TGZu=0$，因为$Z^TGZ&gt;0$，所以$u=0$ 根据$Gu-Av=0$，得到$Av=0\\rightarrow v=0$ 设A行满秩，$Z^TGZ$正定，那么$x^*$是二次规划的唯一全局解 对KKT矩阵准三角化 \\begin{bmatrix}G&-A\\\\-A^T&0\\end{bmatrix} \\begin{bmatrix}I&G^{-1}A\\\\0&I\\end{bmatrix} =\\begin{bmatrix}G&0\\\\-A^T&-A^TG^{-1}A\\end{bmatrix}其中 \\begin{bmatrix}I&G^{-1}A\\\\0&I\\end{bmatrix}^{-1} =\\begin{bmatrix}I&-G^{-1}A\\\\0&I\\end{bmatrix}所以 \\begin{bmatrix}G&-A\\\\-A^T&0\\end{bmatrix} =\\begin{bmatrix}G&0\\\\-A^T&-A^TG^{-1}A\\end{bmatrix} \\begin{bmatrix}I&-G^{-1}A\\\\0&I\\end{bmatrix}带入KKT矩阵，得到 \\begin{bmatrix}G&0\\\\-A^T&-A^TG^{-1}A\\end{bmatrix} \\begin{bmatrix}I&-G^{-1}A\\\\0&I\\end{bmatrix} \\begin{bmatrix}x\\\\\\lambda\\end{bmatrix} =-\\begin{bmatrix}g\\\\b\\end{bmatrix}令 \\begin{bmatrix}w\\\\\\lambda\\end{bmatrix} =\\begin{bmatrix}I&-G^{-1}A\\\\0&I\\end{bmatrix} \\begin{bmatrix}x\\\\\\lambda\\end{bmatrix}\\\\ \\begin{bmatrix}w\\\\\\lambda\\end{bmatrix} =\\begin{bmatrix}x-G^{-1}A\\lambda\\\\\\lambda\\end{bmatrix}则 \\begin{bmatrix}G&0\\\\-A^T&-A^TG^{-1}A\\end{bmatrix} \\begin{bmatrix}w\\\\\\lambda\\end{bmatrix} =-\\begin{bmatrix}g\\\\b\\end{bmatrix} \\\\ \\begin{bmatrix}Gw\\\\-A^Tw-A^TG^{-1}A\\lambda\\end{bmatrix} =-\\begin{bmatrix}g\\\\b\\end{bmatrix}所以得到 \\begin{aligned} &Gw=-g\\\\ &A^TG^{-1}A\\lambda=-A^Tw+b\\\\ &Gx=A\\lambda-g \\end{aligned}我们通过Cholesky分解的方法求解这三个方程，算法分为两部分：第一部分对矩阵G和$A^TG^{-1}A$的分解，第二部分为回代、求解。具体步骤如下： 对矩阵G作Cholesky分解，求下三角阵L，得到$G=LL^T$ 计算$V=A^TG^{-1}A$，求解三角矩阵方程$LY=A$得到Y，则$V=Y^TY$ 在这里，$V=A^TG^{-1}A=A^T(LL^T)^{-1}A=A^TL^{-T}L^{-1}A=(L^{-1}A)^T(L^{-1}A)$ 令$L^{-1}A=Y$，得到$LY=A$，求解后得到$Y$，带入就是$V=Y^TY$ 对$V=A^TG^{-1}A$作Cholesky分解，使得$V=\\tilde{L}\\tilde{L}^T$ 解方程：$Lu=-g,\\quad L^Tw=u$，得到$w$，计算$\\tilde{b}=-A^Tw+b$ 由于$G=LL^T$，带入$Gw=-g$得到$LL^Tw=-g$ 令$u=L^Tw$，则$Lu=-g$，解得$w$，令$\\tilde b = -A^Tw+b$ 解方程：$\\tilde{L}v=\\tilde{b},\\quad \\tilde{L}^T\\lambda=v$,得到$\\lambda^$，再计算$\\tilde{g}=A\\lambda^-g$ 由于$V=\\tilde L\\tilde L^T$，带入得$\\tilde L\\tilde L^T\\lambda=\\tilde b$ 令$v=\\tilde L^T\\lambda$,则$\\tilde Lv=\\tilde b$，解得$\\lambda$。令$\\tilde g = A\\lambda^*-g$ 解方程:$Ly=\\tilde{g},\\quad L^Tx=y$得到$x^*$ 将$G=LL^T$带入$Gx=\\tilde g$，得到$LL^Tx=\\tilde g$ 令$y=L^Tx$,则$Ly=\\tilde g$,解出$x^*$","path":"2021/12/03/数值最优化/二次规划/","date":"12-03","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"https://reiscarlet.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"KKT条件","text":"[TOC] 无约束优化问题——求导首先我们复习下： 给定一个目标函数$f=R^n\\rightarrow R^n$,求出目标函数的最小值，记为： \\large{ min f(x)\\\\ s.t\\ x \\in X }找出最小值的办法很简单，就是单纯的对$f(x)$求导，令导数等于0，得到的解$x^*$就是目标函数的极小值点了 等式约束优化问题——拉格朗日乘子法首先，梯度方向是函数值增长最快的方向。 给定一个目标函数$f = R^n \\rightarrow R^n$，在满足约束条件$g(x) = 0$的前提下，使得$f(x)$有最小值。这个约束问题记为： \\large{ min\\ f(x) \\\\ s.t\\ g(x) = 0\\\\ }假如P点是f（x）在约束条件g（x）下的极值点，假设一个参数方程$\\large{r(t)=(x_1(t),x_2(t)…x_n(t))}$是一个曲线，它在约束条件的表面，切$\\large{r(0)=P}$点，假设$\\large{h(t)=f(x_1(t),x_2(t)….,x_n(t))} = f(r(t))$ 则有$\\large{h’(t)=\\nabla f(x)|_{r(t)}\\cdot r’(t)}$ 又因为P点为极值点，所以$\\large{h’(t)=\\nabla{f}|_{P}\\cdot{r’(t)}=0}$ 所以$\\large{f|_{P}}$在点P处垂直于$\\large{r(t)}$。而$\\large{r(t)}$是约束面上的任意曲线，所以$\\large{f|_{p}}$在P处垂直于$\\large{g(x)=0}$ 所以$\\large{\\nabla{f|_{P}=\\lambda{\\nabla{g_P}}}}$ 所以$\\large{\\nabla{f(x)=\\lambda{\\nabla g(x)}}} \\rightarrow \\nabla f(x)-\\lambda\\nabla g(x) =0$ 所以令$\\large{L(x,\\lambda)=f(x)-\\lambda g(x)}$。对它求导，令导数=0得到的点就是极值点.即 \\large{\\left\\{ \\begin{aligned} \\nabla f(x) &= \\lambda \\nabla g(x) \\\\ g(x) &= 0 \\end{aligned} \\right.}不等式约束优化问题——KKT条件对于不等式约束的优化 \\large{min\\ f(x)\\\\s.t\\quad g(x)\\leq 0}等价于 \\large{ min_x\\ max_\\lambda\\ f(x) + \\lambda{g(x)}\\\\ s.t \\quad \\lambda \\ge 0 }对于等式约束，由于$\\large \\lambda{g(x)}=0$恒成立，所以对因子没有约束，但是不等式约束中，我们必须对因子进行约束 对于$\\large{g(x)\\leq0}$，我们引入一个松弛变量$\\large{a^2}$，使得$\\large{g(x)+a^2}=0$，这样我们把不等式约束转化为等式约束问题了 对等式约束使用拉格朗日乘子法，有拉格朗日函数 $\\large{L(x,\\lambda, a)=f(x) + \\lambda(g(x)+a^2)}$，则有 \\large{\\left\\{ \\begin{aligned} \\frac{\\partial L}{\\partial x^*} &= \\nabla f(x^*) + \\sum_i^{m}\\lambda_i\\nabla g_i(x^*) = 0(i=1,2,...,m) \\quad (1)\\\\ \\frac{\\partial L}{\\partial \\lambda} &= \\sum_i^{m}g_i(x^*) + a^2 = 0(i=1,2,...,m) \\quad (2)\\\\ \\frac{\\partial L}{\\partial a} &= 2a\\lambda_i = 0(i=1,2,...,m) \\quad(3)\\\\ \\end{aligned} \\right.}对(3)式 $\\lambda$等于0，a不等于0时，得到g(x)&lt;0，$\\lambda g(x)$=0，可认为g(x)不起约束 a等于0，$\\lambda$不等于0，得到g(x)=0，所以$\\lambda&gt;0$。g(x)起到了约束作用 综上，可以发现 $\\large{\\lambda\\geq0}\\quad(4)$。乘子大于等于0从目标函数就可以看出，不等式约束小于0，目标函数又是最小化，乘子肯定大于等于0。 $\\large{\\lambda g(x) = 0}$，因为$\\large g(x)和\\lambda$总有一个为0 所以我们的得到，对不等式约束 $\\large{min\\ f(x) \\\\ s.t\\quad g(x)\\leq 0}$ 我们有 \\large{ \\left\\{ \\begin{align} & \\nabla f(x^*) + \\sum_i^{m}\\lambda_ig_i(x^*) = 0(i=1,2...m)\\\\ & \\lambda_ig_i(x^*) = 0(i=1,2...m)\\\\ & \\lambda_i > 0(i=1,2...m) \\end{align} \\right. }更一般的，有约束问题 \\large{ \\begin{align} min&f(x) \\\\ s.t.\\ &g_j(x)\\leq0(j=1,2,...,m)\\\\ &h_j\\ (x) = 0(j=1,2,...,m) \\end{align} }KKT条件为： \\large{\\left\\{ \\begin{align} & \\nabla f(x) + \\sum_{j=1}^{m}\\mu_j\\nabla{g_j(x)} + \\sum_{k=1}^{l}\\lambda_k\\nabla{h_k(x)}=0,(i=1,2,...,n)\\\\ & h_k(x) = 0(k=1,2,...,l) \\\\ & \\mu_j{g_j(x)} = 0(j=1,2,...,m)\\\\ & g_j(x) < 0(j=1,2,...,m)\\\\ & \\mu_j \\geq 0(j=1,2,...,m) \\end{align} \\right. }","path":"2021/12/03/数值最优化/KKT条件/","date":"12-03","excerpt":"","tags":[]},{"title":"单件模式Singleton","text":"对象性能模式面向对象很好地解决了”抽象”问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。 1.1 动机在软件系统中，经常有一些特殊的类，必须保证它们在系统中只存在一个实例，才能保证它们的逻辑正确性、以及良好的效率 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？虽然类的使用者可以在编写代码的时候自己处理。但是这应该是类设计者的责任 1.2 讲解下面是一个最初版本的Singleton模式的代码 12345678910111213141516class Singleton&#123;public: Singleton()=delete; Singleton(const Singleton&amp;)=delete; static Singleton* getInstance(); static Singleton* m_instance;&#125;;Singleton* Singleton::m_instance = nullptr;Singleton* Singleton::getInstance()&#123; if(m_instance == nullptr)&#123; m_instance = new Singleton(); &#125; return m_instance;&#125; 在以上的版本中，getInstance()有个问题就是线程不安全。单线程情况下能正常运行。但在多线程环境下，如果线程A进入第13行后，线程B被调度，这时候m_instance还是nullptr，那么线程B仍然能进入第13行。那么两个线程完成后，全局就有两个Singleton实例了，违背了Singleton模式的初衷了。 我们可以用锁机制来改进这个问题 1234567891011121314151617181920class Singleton&#123;public: Singleton()=delete; Singleton(const Singleton&amp;)=delete; static Singleton* getInstance();private: std::mutex m_mutex; static Singleton* m_instance;&#125;;Singleton* Singleton::m_instance = nullptr;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance()&#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); if(m_instance == nullptr)&#123; m_instance = new Singleton(); &#125; return m_instance;&#125; 虽然这样子实现了线程安全，但是以上实现有个问题，锁机制的代价太高了。这样子如果有很多读操作情况下，由于锁机制的自旋会影响性能，但读操作过程是不需要进行锁机制的保护的。所以我们对这个函数继续改变，使用双检查锁来进行优化 123456789Singleton* Singleton::getInstance()&#123; if(m_instance == nullptr)&#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); if(m_instance == nullptr)&#123; m_instance = new Singleton(); &#125; &#125; return m_instance;&#125; 以上实现很好的解决了读操作过程中锁机制带来的性能问题。这样只要m_instance不是nullptr，那么就只会直接返回一个现有的实例。而不会进入锁机制的判断。 但上述代码还有一个问题，那就是在编译器对代码优化过程中，翻译后的汇编指令通常顺序不和我们编写的代码一样。例如m_instance = new Singleton()这条代码，通常情况下，都是先给m_instance分配内存，调用Singleton()构造器，然后地址赋值。但实际情况下，却有可能是这样子的：先调用构造器，然后地址赋值，最后给m_instance分配内存。 在上述代码中，如果编译器是先给m_instance分配内存，然后return m_instance，最后才是调用构造器的话，返回值的结果可能是不正确的。也就是reorder不安全。为此我们需要告诉编译器，这段代码不要进行一个reorder的优化。在Java等语言中，我们可以对m_instance变量声明为一个volatile，而c++在11标准后，我们可以像如下处理 12345678910111213141516std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance()&#123; Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if(tmp == nullptr)&#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if(tmp == nullptr)&#123; tmp = new Singleton(); std::atomic_thread_fence(std::memory_order_release); m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 这样，第5行代码执行后，直到第11行执行完之前，tmp有关的代码都不能进行reorder优化。也就是reorder安全和线程安全全部得到保证 1.3 模式定义保证一个类仅有一个实例，并提供一个该实例的全局访问点 1.4 结构 1.5 要点总结 Singleton模式的实例构造器可以设置为protected以允许子类派生 Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背 如何实现多线程下安全的Singleton？注意对双检查锁的正确实现","path":"2021/12/03/设计模式/对象性能模式/单件模式/","date":"12-03","excerpt":"","tags":[{"name":"编程","slug":"编程","permalink":"https://reiscarlet.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"","text":"","path":"2021/12/03/设计模式/对象性能模式/享元模式/","date":"12-03","excerpt":"","tags":[]},{"title":"构建器Builder","text":"1.1 动机在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临剧烈的变化，但是它们组合在一起的算法却相对稳定。 如何应对这种变化？如何提供一种”封装机制”来隔离出”复杂对象的各个部分”的变化，从而保持系统的”稳定构建算法”不随着需求的变化而变化 1.2 讲解1234567891011121314151617class House&#123;public: void Init()&#123; this-&gt;BuildPart1(); //各种处理... this-&gt;BuildPart2(); this-&gt;BuildPart3(); this-&gt;BuildPart4(); this-&gt;BuildPart5(); &#125;protected: virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;; 这就是最简单的Builder了。在这个类House中，House的各个BuildPart的实现可以有很多种，但是它们的构建却在Init中很稳定。举个例子就是，House都是由Window，Door之类的组成，但每个House的Window和Door的实现可能都不同。 我们可以对House进行拓展，如下 12345678910111213141516171819202122232425262728293031class House&#123;public: void Init()&#123; this-&gt;BuildPart1(); //各种处理... this-&gt;BuildPart2(); this-&gt;BuildPart3(); this-&gt;BuildPart4(); this-&gt;BuildPart5(); &#125;protected: virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;;class StoneHouse : public House&#123;protected: virtual void BuildPart1()&#123;/*实现*/&#125; virtual void BuildPart2()&#123;/*实现*/&#125; virtual void BuildPart3()&#123;/*实现*/&#125; virtual void BuildPart4()&#123;/*实现*/&#125; virtual void BuildPart5()&#123;/*实现*/&#125; &#125;;int main()&#123; House* pHouse = new StoneHouse(); pHouse-&gt;Init();//Builder&#125; 在这里，House的Init也就是对象的构建和其实现（各种BuildPart）分离，这样在main中的pHouse指向不同对象时，Init出来的对象也就不同。实现同样的构建过程（Init里的步骤）创建不同的表示（StoneHouse实现的BuildPart） 但是，当一个类的构建过程十分的臃肿时，我们需要将对象的构建(也就是Init)抽出来。如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class House&#123; // 对象的表示&#125;;class HouseBuilder&#123;public: House* GetResult()&#123; return pHouse; &#125; virtual ~HouseBuilder()&#123;&#125;protected: House* pHouse; virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;;class StoneHouse : public House&#123;&#125;;class StoneHouseBuilder : public HouseBuilder&#123;protected: virtual void BuildPart1()&#123;/*实现*/&#125; virtual void BuildPart2()&#123;/*实现*/&#125; virtual void BuildPart3()&#123;/*实现*/&#125; virtual void BuildPart4()&#123;/*实现*/&#125; virtual void BuildPart5()&#123;/*实现*/&#125; &#125;;class HouseDirector &#123;public: HouseBuilder* pHouseBuilder; HouseDirector(HouseBuilder* pHouseBuilder)&#123; this-&gt;pHouseBuilder = pHouseBuilder; &#125; House* Construct()&#123; // Init pHouseBuilder-&gt;BuildPart1(); //各种处理... pHouseBuilder-&gt;BuildPart2(); pHouseBuilder-&gt;BuildPart3(); pHouseBuilder-&gt;BuildPart4(); pHouseBuilder-&gt;BuildPart5(); return pHouseBuilder-&gt;GetResult(); &#125;&#125;;int main()&#123; HouseBuilder* pHouseBuilder = new StoneHouseBuilder(); HouseDirector houseDirector = new HouseDirector(pHouseBuilder); House* pHouse = houseDirector-&gt;Construct();&#125; 1.3 模式定义将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示 1.4 模式结构 1.5 要点总结 Builder模式主要用于”分步骤构建一个复杂的对象”。在这其中”分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化 变化点在哪里，封装哪里——Builder模式主要在于应对”复杂对象各个部分”的频繁需求变化。其缺点在于难以应对”分步骤构建算法”的需求变动 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别(C++和Java等)","path":"2021/12/03/设计模式/对象创建模式/构建器/","date":"12-03","excerpt":"","tags":[{"name":"编程","slug":"编程","permalink":"https://reiscarlet.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"抽象工厂Abstract Factory","text":"1.1 动机在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作“；同时，由于需求的变化，往往存在更多系列对象的创建工作 1.2 讲解12345678class EmployeeDao&#123;public: vector&lt;EmployeeD0&gt; GetEmployees()&#123; SqlConnection* connection = new SqlConnection(); SqlCommand* command = new SqlCommand(); //...... &#125;&#125;; 在上面的代码中，SqlConnection是面对Sql Server的Connection对象，这样的紧耦合不适应于变化，如果由于需求我们要换数据库为MySQL，我们得对EmployeeDao进行修改，所以首先基于”面向接口编程“的思想，我们可以进行一些改动 123456789101112131415161718// 接口class IDBConnection&#123;&#125;;class IDBCommand&#123;&#125;;// SqlServerclass SqlConnection : public IDBConnection&#123;&#125;;class SqlCommand : public IDBCommand&#123;&#125;;// Oracleclass OracleConnnection : public IDBConnection&#123;&#125;;class OracleCommand : public IDBCommand&#123;&#125;;class EmployeeDao&#123;public: vector&lt;EmployeeD0&gt; GetEmployees()&#123; IDBConnection* connection = new SqlConnection(); IDBCommand* command = new SqlCommand(); //...... &#125;&#125;; 改变后，我们还剩下new的问题，不然EmployeeDao还是依赖于具体类，所以我们使用Factory Method模式来解决这个问题 1234567891011121314151617181920212223242526272829303132333435// 接口class IDBConnection&#123;&#125;;class IDBConnectionFactory&#123;public: virtual IDBConnection* CreateDBConnection()=0; virtual ~IDBConnectionFactory()&#123;&#125;&#125;;class IDBCommand&#123;&#125;;class IDBCommandFactory&#123;public: virtual IDBCommand* CreateDBCommand()=0; virtual ~IDBCommandFactory()&#123;&#125;&#125;;// SqlServerclass SqlConnection : public IDBConnection&#123;&#125;;class SqlConnectionFactory : public IDBConnectionFactory&#123;&#125;;class SqlCommand : public IDBCommand&#123;&#125;;class SqlCommandFactory : public IDBCommandFactory&#123;&#125;;// Oracleclass OracleConnnection : public IDBConnection&#123;&#125;;class OracleConnectionFactory : public IDBConnectionFactory&#123;&#125;;class OracleCommand : public IDBCommand&#123;&#125;;class OracleCommandFactory : public IDBCommandFactory&#123;&#125;;class EmployeeDao&#123; IDBConnectionFactory* dbConnectionFactory; IDBCommandFactory* dbCommandFactory;public: vector&lt;EmployeeD0&gt; GetEmployees()&#123; IDBConnection* connection = dbConnectionFactory-&gt;CreateConnection(); IDBCommand* command = dbCommandFactory-&gt;CreateCommand(); //...... &#125;&#125;; 这个时候我们的EmployeeDao就不依赖于任何具体类了，dbConnectionFactory指向SqlConnectionFactory，CreateConnection就返回SqlConnection的对象，dbConnectionFactory指向OracleConnectionFactory，CreateConnection就返回OracleConnection对象 但是此时还有一个问题，那就是，我们的Connection和Command是有关联的，一般不可能connection是连接的SqlServer的数据库，而Command却是对Oracle的操作。所以我们这时候就使用另一种叫做”Abstract Factory”模式，如下 12345678910111213141516171819202122232425262728// 接口class IDBConnection&#123;&#125;;class IDBCommand&#123;&#125;;class IDBFactory&#123;public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual ~IDBConnectionFactory()&#123;&#125;&#125;;// SqlServerclass SqlConnection : public IDBConnection&#123;&#125;;class SqlDBFactory : public IDBFactory&#123;&#125;;class SqlCommand : public IDBCommand&#123;&#125;;// Oracleclass OracleConnnection : public IDBConnection&#123;&#125;;class OracleDBFactory : public IDBFactory&#123;&#125;;class OracleCommand : public IDBCommand&#123;&#125;;class EmployeeDao&#123; IDBFactory* dbFactory;public: vector&lt;EmployeeD0&gt; GetEmployees()&#123; IDBConnection* connection = dbFactory-&gt;CreateConnection(); IDBCommand* command = dbFactory-&gt;CreateCommand(); //...... &#125;&#125;; 将有关联的工厂集合在一个抽象类中，这样IDBFactory*指向SqlDBFactory时，所创建的Connection和Command对象就是同属于对SQL Server的操作了 1.3 模式定义提供一个接口，让该接口负责创建一系列”相关或者相互依赖的对象“，无需指定它们具体的类 1.4 结构 1.5 要点总结 “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖 Abstract Factory模式主要在于应对”新系列”的需求变动。其缺点在于难以应对”新对象”的需求变动，例如对IDBFactory添加一个新的接口 如果没有应对”多系列对象创建”的需求变化，则完全没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以","path":"2021/12/03/设计模式/对象创建模式/抽象工厂/","date":"12-03","excerpt":"","tags":[{"name":"编程","slug":"编程","permalink":"https://reiscarlet.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"工厂模式Factory  Method","text":"对象创建模式通过”对象创建模式“绕开new，来避免对象创建new过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。 1.1 动机在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种”封装机制“来避免客户程序和这种”具体对象创建工作“的紧耦合？ 1.2 讲解1234567891011class FileSplitter&#123;public: void split()&#123; ... &#125; &#125;;// 拓展class TxtSplitter&#123;&#125;;class PitureSplitter&#123;&#125;;class VideoSplitter&#123;&#125;; 1234567class MainForm : public Form&#123;public: void Button1_click()&#123; FileSplitter* splitter = new FileSplitter(); splitter-&gt;split(); &#125;&#125;; 在上面的例子中，我们可以发现，如果我们要拓展的时候我们就必须修改MainForm中的第4行代码，因为第四行，依赖具体的类，这样如果要处理别的类时，我们就需要对MainForm进行修改，从而可能影响所有使用它的类。造成软件的不稳定和不可维护性 我们可以对各种Splitter进行抽象 123456789101112class ISplitter&#123;public: virtual void split()=0; virtual ~ISplitter()&#123;&#125;&#125;;//具体类class BinarySplitter : public ISplitter&#123;&#125;;// 以下为拓展class TxtSplitter : public ISplitter&#123;&#125;;class PitureSplitter : public ISplitter&#123;&#125;;class VideoSplitter : public ISplitter&#123;&#125;; 12345678class MainForm : public Form&#123;public: void Button1_click()&#123; ISplitter* splitter = new BinarySplitter(); //依赖具体类 splitter-&gt;split(); &#125;&#125;; 根据依赖倒置原则。虽然MainForm中的第4行虽然依赖抽象，但是此时第5行还是依赖具体类，此时MainForm的编译还是依赖BinarySplitter、TxtSplitter、PitureSplitter和VideoSplitter等具体类的存在 我们做如下处理 1234567//抽象类class SplitterFactory&#123;public: ISplitter* CreateSplitter()&#123; return new BinarySplitter(); &#125;&#125;; 12345678class MainForm : public Form&#123; SplitterFactory factory;public: void Button1_click()&#123; ISplitter* splitter = factory.CreateSplitter(); splitter-&gt;split(); &#125;&#125;; 但是此时MainForm依赖SplitterFactory，SplitterFactory依赖BinarySplitter，MainForm还是依赖一个具体的类BinarySplitter，如果我们改为对一个TxtSplitter进行处理，我们还是得对MainForm，SplitterFactory进行修改 所以我们应该对各种工厂进行一个抽象，如下图 123456// 工厂的抽象class SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()=0; virtual ~SplitterFactory()&#123;&#125;&#125; 12345678class MainForm : public Form&#123; SplitterFactory* factory;public: void Button1_click()&#123; ISplitter* splitter = factory-&gt;CreateSplitter(); splitter-&gt;split(); &#125;&#125;; 此时，MainForm代码中第5行等号左边依赖抽象类，等号右边也是依赖抽象类。CreateSplitter返回值创建的未来交给”未来“，可以是BinarySplitter，也可以是TxtSplitter等别的，而MainForm也不用进行改变 完善后 12345678910111213141516171819202122232425262728// 具体工厂class BinarySplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new BinarySplitter(); &#125;&#125;;class TxtSplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new TxtSplitter(); &#125;&#125;;class VideoSplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new VideoSplitter(); &#125;&#125;;class PictureSplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new PictureSplitter(); &#125;&#125;; 123456789101112class MainForm : public Form&#123; SplitterFactory* factory;public: MainForm(SplitterFactory* factory)&#123; this-&gt;factory = factory; &#125; void Button1_click()&#123; ISplitter* splitter = factory-&gt;CreateSplitter();//多态new splitter-&gt;split(); &#125;&#125;; 这样，this-&gt;factory的具体指向就是外部传进来的，例如BinaryFacotry或者别的，这样factory-&gt;CreateSplitter就是this-&gt;factory对应的CreateSplitter所返回的值。这样MainForm就稳定下来了。 设计模式不把问题消灭，而是转移问题到另一个地方。 1.3 模式定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦合）到子类 1.4 结构 1.5 要点总结 Factory Method模式常用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系new会导致软件的脆弱 Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种拓展（而非更改）的策略，较好地解决了紧耦合的问题 Factory Method模式解决”单个对象“的需求变化。缺点在于要求创建方法/参数相同","path":"2021/12/03/设计模式/对象创建模式/工厂模式/","date":"12-03","excerpt":"","tags":[{"name":"编程","slug":"编程","permalink":"https://reiscarlet.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"原型模式Prototype","text":"1.1 动机在软件系统中，经常面临着”某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有稳定一致的接口 如何应对这种变化？如何向”客户程序(使用这些对象的程序)”隔离出”这些易变对象”，从而使得这些易变对象的客户程序”不需要随着需求改变而改变” 1.2 讲解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 工厂的抽象class SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()=0; virtual ~SplitterFactory()&#123;&#125;&#125;;// 抽象类class ISplitter&#123;public: virtual void split()=0; virtual ~ISplitter()&#123;&#125;&#125;;// 具体工厂class BinarySplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new BinarySplitter(); &#125;&#125;;class TxtSplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new TxtSplitter(); &#125;&#125;;class VideoSplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new VideoSplitter(); &#125;&#125;;class PictureSplitterFacotry : public SplitterFactory&#123;public: virtual ISplitter* CreateSplitter()&#123; return new PictureSplitter(); &#125;&#125;;//具体类class BinarySplitter : public ISplitter&#123;&#125;;class TxtSplitter : public ISplitter&#123;&#125;;class PitureSplitter : public ISplitter&#123;&#125;;class VideoSplitter : public ISplitter&#123;&#125;;// 客户程序class MainForm : public Form&#123; SplitterFactory* factory;public: MainForm(SplitterFactory* factory)&#123; this-&gt;factory = factory; &#125; void Button1_click()&#123; ISplitter* splitter = factory-&gt;CreateSplitter();//多态new splitter-&gt;split(); &#125;&#125;; 我们可以对抽象类进行一些改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 抽象类class ISplitter&#123;public: virtual void split()=0; virtual ISplitter* clone()=0;//原来是CreateSplitter() virtual ~ISplitter()&#123;&#125;&#125;;//具体类class BinarySplitter : public ISplitter&#123;public: ISplitter* clone()&#123; return new BinarySplitter(*this);//使用拷贝构造函数 &#125;&#125;;class TxtSplitter : public ISplitter&#123;public: ISplitter* clone()&#123; return new TxtSplitter(*this); &#125;&#125;;class PitureSplitter : public ISplitter&#123;public: ISplitter* clone()&#123; return new PitureSplitter(*this); &#125;&#125;;class VideoSplitter : public ISplitter&#123;public: ISplitter* clone()&#123; return new VideoSplitter(*this); &#125;&#125;;// 客户程序class MainForm : public Form&#123; ISplitter* prototype;public: MainForm(ISplitter* prototype)&#123; this-&gt;prototype = prototype; &#125; void Button1_click()&#123; ISplitter* splitter = prototype-&gt;clone();//克隆原型 splitter-&gt;split(); &#125;&#125;; 这样，当你对象达到某个状态时，你就能通过clone把对象的状态通过拷贝构造函数取出来并返回，而不是在每一次用Factory创建一个对象后再想方设法的达到你要的状态，甚至在这个过程中无法达到的这个状态。而用原型模式，只要达到了一个状态，以后的使用就直接clone它就行了 也就是说，当你创建一个对象时，如果要考虑复杂的中间状态时，考虑的应该是原型模式。如果只是简单的创建一个对象，那么工厂模式更好 1.3 模式定义 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象 1.4 结构 1.5 要点总结 prototype模式同样用于隔离类对象的使用者和具体类型之间的耦合关系，它同样要求这些”易变类”具有”稳定的接口” prototype模式对于”如何创建易变类的实体对象”采用”原型克隆”的方法，使得我们可以非常灵活地动态创建”具有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象(原型)，然后在任何需要的对象clone prototype模式中的clone方法可以利用某些框架中的序列化来实现深拷贝","path":"2021/12/03/设计模式/对象创建模式/原型模式/","date":"12-03","excerpt":"","tags":[{"name":"编程","slug":"编程","permalink":"https://reiscarlet.github.io/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"","text":"","path":"2021/12/03/设计模式/观察者模式/","date":"12-03","excerpt":"","tags":[]},{"title":"","text":"1.装饰模式1.1动机为某些情况下我们可能会”过度地使用继承来扩展对象的功能“，由于继承为类型引入的静态性质，使得这种拓展方式缺乏灵活性；并且随着子类的增多(拓展功能的增多)，各种子类的组合(拓展功能的组合)会导致更多子类的膨胀 1.2 讲解1.3 模式定义动态（组合）地给一个对象增加一些额外地职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数） 1.4 结构1.5 要点总结 通过采用组合而非继承地方式，Decorator模式实现了在运行时动态拓展对象功能的能力，而且可以根据需要拓展多个功能。避免了使用继承带来的”灵活性差“和”多子类衍生问题“ Decorator类在接口上表现为is-a Component的继承关系，但在实现上又变现为has-a Component的组合关系（同时有is-a和has-a的时候，要考虑是不是用了decorator模式） Decorator模式的目的并非为了解决”多子类衍生的多继承问题“，Decorator模式应用的要点在于解决”主体类在多个方向上的拓展功能“——是为”装饰“的含义","path":"2021/12/03/设计模式/装饰模式/","date":"12-03","excerpt":"","tags":[]},{"title":"","text":"","path":"2021/12/03/设计模式/策略模式/","date":"12-03","excerpt":"","tags":[]},{"title":"","text":"","path":"2021/12/03/设计模式/模板模式/","date":"12-03","excerpt":"","tags":[]},{"title":"","text":"1.Brige桥模式1.1 动机","path":"2021/12/03/设计模式/桥模式/","date":"12-03","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/05/21/hello-world/","date":"05-21","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"存储系统","slug":"存储系统","permalink":"https://reiscarlet.github.io/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"},{"name":"笔记","slug":"笔记","permalink":"https://reiscarlet.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"IP网络协议","slug":"IP网络协议","permalink":"https://reiscarlet.github.io/tags/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"运输层","slug":"运输层","permalink":"https://reiscarlet.github.io/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"},{"name":"网络层","slug":"网络层","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"链路层","slug":"链路层","permalink":"https://reiscarlet.github.io/tags/%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"name":"路由技术","slug":"路由技术","permalink":"https://reiscarlet.github.io/tags/%E8%B7%AF%E7%94%B1%E6%8A%80%E6%9C%AF/"},{"name":"交换技术","slug":"交换技术","permalink":"https://reiscarlet.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/"},{"name":"计算机网络概述","slug":"计算机网络概述","permalink":"https://reiscarlet.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"name":"网络传输、设备与企业网架构","slug":"网络传输、设备与企业网架构","permalink":"https://reiscarlet.github.io/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E3%80%81%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BD%91%E6%9E%B6%E6%9E%84/"},{"name":"物理层","slug":"物理层","permalink":"https://reiscarlet.github.io/tags/%E7%89%A9%E7%90%86%E5%B1%82/"},{"name":"应用层","slug":"应用层","permalink":"https://reiscarlet.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"数学证明","slug":"数学证明","permalink":"https://reiscarlet.github.io/tags/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"},{"name":"数学","slug":"数学","permalink":"https://reiscarlet.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"编程","slug":"编程","permalink":"https://reiscarlet.github.io/tags/%E7%BC%96%E7%A8%8B/"}]}